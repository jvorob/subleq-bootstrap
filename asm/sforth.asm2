# First attempt at writing a threaded-interpreter
# (i.e. forth-style inner loop, can simply list addresses of subroutines and it will nest them properly)
#
# ==== MAIN FORTH TODO ======:
#
# Low priority:
# - FLAGS? [F_IMMED], bitwise ops [needed for 2nd outer interp, but doing it lazily for now]
# - shifts, bitwise ops
# - STRCHARS can just be a CMOVE into stack space, with special case for TOS
#
# LONG-TERM-PROJECT: NEG-OPTIMIZATION?
# - word-addresses negative? (fetch CWA goes from 3 to 1)
# - codeword address negative? (jmp(*CWA) goes from 4 to 2)
# - codewords 0 0 CW? (jmp(*CWA) goes from 4 to 1)
# - variables/constants negative?
#
# PUSH-POP OPTIMIZATION? (not worth it)
# - psh/pop gadgets as subroutines?
#   - all SP inc/dec would need to be set in 4 places
#   - would need to handle returns
#   - COSTS:
#       push is 2 ops + return
#       pop is  1 op + return (clear X as you call)
#   - Calling cost: 3 ops

# ===== NOTES ON MEMORY LAYOUT, CALLING CONVENTIONS, ETC
# = Notes on signedness:
# In memory strings are (+)
# In vars, chars are usually (-)
# In memory values are usually (-) (so + when read)
# Pointers in vars are usually (-) (so + when peeked/poked)
# Pointers in globals are usually (+) (so - when they go into vars?)
#
# = Notes on register conventions:
# ??
#
# = Notes on call/return conventions:
# ??
#
# = Notes on exiting / error catching:
# - uninitialized memory is at 0d
# - If we jump to 0d, we should halt (need 0f to point back to 0d)
# - If we forth jump to 0d, we should read
#
# ===== Forth Notes:
# XXXX_hdr is a dictionary header
# XXXX_wd is the code-field-address, ie. an execution token
# XXXX_cd is assembly code that can be jumped to
# XXXX_bd is body of secondary word

# Dictionary header is LINK, FLAGS, STRLEN, [STR...], CF, BODY
# =========  HEADER

@0 # Z T entry       P1  M1  0 0
Z:0 T:0 entry: 2000

@8 # IO ports
IN: 0
OUT: 0
alu_A: 0
alu_B: 0

# == Uninitialized mem catcher
#   if we jump to uninitialized memory, we'll clear 0d, then jump here
#       we'll then execute 0 0 0100 and jump to catch_bad_mem
#
#   if we execute a random memory address as a forth word, the CWA would contain 0d, so
#       we would jump directly to 0d without clearing it.
#       NOTE: 110 must contain a 0 so that this still always jumps
#
#   if we run off the end of a forth word, we'll treat 0d as an execution token/word address
#       the CWA would contain this will set CWA=0d, and will jump to *(0d), which is 0D9 == halt3
#
@0d   110 00 0100

@10 #ALU outputs
# & | ^ _   << >> _ _
alu_and: 0
alu_or: 0
alu_xor: 0
0
alu_ls: 0
alu_rs: 0
alu_ars: 0

# ========  REGISTERS AND CO.

@20 #Unsaved registers, used for primitive routines
X:0 Y:0 V:0 W:0
P1:0 P2:0 Q1:0 Q2:0

#Saved registers (only modify these if you're top-level, or save them first)
#(TODO)
@28 #
      0  0  0  0     0  0  0   @2F R: 0

@30 #Global vars (_ indicates it's negated)
C_:0  C_needs_fetch:1

#C is last char read (-)   (treated as first char of input)
#C_needs_fetch will be 0 if C_ holds a valid char
#    That way if C already holds a previous char, we
#    can skip fetching a fresh one like so:
#      Z C_needs_fetch ?+6
#          C_ C_; IN C_;  # needs_fetch=1, fetch a fresh char
#      # else, needs_fetch==0, we already had one



# ======== Small integer constants:

@40
#4_: Positive ints: 0-F
i0: 0  i1: 1  i2:  2 i3:  3 i4:  4 i5:  5 i6: 6  i7:  7
i8: 8  i9: 9  iA: 0A iB: 0B iC: 0C iD: 0D iE: 0E iF: 0F

@50
#5_: Negative ints: -0 - -F
    00000 n1: 0FFFF n2: 0FFFE n3: 0FFFD n4: 0FFFC n5: 0FFFB n6: 0FFFA n7: 0FFF9
n8: 0FFF8 n9: 0FFF7 nA: 0FFF6 nB: 0FFF5 nC: 0FFF4 nD: 0FFF3 nE: 0FFF2 nF: 0FFF1

@80
#8_: 00-F0 (tens)
      0  i10: 10  i20: 20  i30: 30  i40: 40  i50: 50  i60: 60  i70: 70
i80: 80  i90: 90  iA0: 0A0 iB0: 0B0 iC0: 0C0 iD0: 0D0 iE0: 0E0 iF0: 0F0

@90
#9_: (-00) - (-F0)
     00000 n10: 0FFF0 n20: 0FFE0 n30: 0FFD0 n40: 0FFC0 n50: 0FFB0 n60: 0FFA0 n70: 0FF90
n80: 0FF80 n90: 0FF70 nA0: 0FF60 nB0: 0FF50 nC0: 0FF40 nD0: 0FF30 nE0: 0FF20 nF0: 0FF10



# ======== Misc jump spots

@0D0 #error_page
halt0:   0  0 0D0    #D0:   halt0 #success
halt1:   1  1 0D3    #D3:   err: halt1 #
halt2:   2  2 0D6    #D6:   err: halt2 # Tried to forth-execute word 0d
halt3:   3  3 0D9    #D9:   err: halt3 # Jumped to 0d (probably forth-executed word pointing to invalid memory)
halt4:   4  4 0DC    #DC:   err: halt4 # Executed 0d 0d 0d


@0F0 retsub:
 ?+7 ?+6    ?    #
   R ?+3    ?    #set Q = -R
   Z   Z  0FF    #jmp -R  (FF temp, gets Q)

#more errors
@100  catch_bad_mem: # jumping to 0d ends up here
    # if we jumped to uninitialized memory, we'd first execute 0d 0d 0d, so 0d will be 0
    Z Z ; Z 0d halt4 # if 0d == 0, halt4

    # else, 0d still contains 0D6, so we must have jumped directly to 0d
    Z Z halt3 # halt3

@110 catch_bad_word: # executing a WA of 0d will load this as the interpreter
    # Note: address 110 must be 0 so that jumping to 0D yields LEQZ and jumps
    Z Z halt2

@120
halt5: 5 5 halt5 #halt5: divide by zero
halt6: 6 6 halt6 #halt6: not implemented
halt7: 7 7 halt7 #halt7:
#halt7: 7 7 halt7 #halt7:
#halt7: 7 7 halt7 #halt7:
#halt7: 7 7 halt7 #halt7:
haltE: 0E 0E haltE #haltE: EOF


# ====================== CORE FORTH VARS
@180
# NWA/CWA: in-code pointers (see NEXT_cd:)

# VARS:

# Stacks: We want to keep the top of stack in a var for easier access
TOS: 0 #Will be initialized to 0CAFE canary value
NOSP_: 0 #NOSP(-) points to NOS, i.e. 1 below TOS
# NOTE: initialized to point 2 higher than stack_base: i.e. at stack canary
#       initial (invalid) value of TOS will be pushed to canary (base+1), then first real val will be at stack_base

#TORS: 0
RSP_: 0 #RSP(-) points to next free space

#Data stack (grows downward)
@210 dstack_limit: 0CAFE
@300 dstack_base: 0d #TOS will go here
    0CAFE #canary
    0CAFE #canary2 (we'll pop this into TOS if we . with an empty stack)

@310 rstack_limit: 0CAFE
@400 rstack_base: 0d #Return stack (grows downward)
    0CAFE #canary

# Token buffer (NOTE: first location is length)
@440 token_buff:
@480 #end of token buffer
#


@550 # strcmp:
strcmp:
# We have two strings, the lengths matched
# (strings with lengths at strp[0])
# P1(-), P2(-) point to their start (length byte)
# Return value in X: 1 if ==, else 0
#
# Y- will hold strlen 1
# V- will hold strlen 2
#
# X will hold loop counter (-len)
# W: tmp, test char
# cP1 will hold ptr to curr char of iter str
# cP2 will hold ptr to curr char of new-interning str

    #Fetch lengths into Y and V
    Y Y; ?+5 ?+4; P1 ?+1; 0 Y; # GADGET:FETCH Y = -*(-P1)
    V V; ?+5 ?+4; P2 ?+1; 0 V; # GADGET:FETCH V = -*(-P1)

    # Check if lengths match (Y-V=0)
    Y V ?+3  # if V-Y <= 0, jump nextif
    Z Z 5E0  # else V-Y >0, jump strcmp_neq
    V Z ?+3  # nextif V-Y >= 0 (V-Y==0): strcmp worked
    Z Z 5E0  # else V-Y < 0, jump strcmp_neq

    # If we get here, lengths matched, do strcmp
    Z Z; X X;
    Y Z; Z X; Z Z; # X- = len Y(-)
    n1 X;     # X++ ( len-- )

    # Write ptrs into fetchloop code
    5AC 5AC; P1 5AC;  # cmpP1+ = (P1)  (loop skips len field)
    5AF 5AF; P2 5AF;  # cmpP2+ = (P2)  (loop skips len field)
    Z Z 5A0 #jmp to strcmp loop

@5A0 #strcmp_loop:
    # advance ptrs (+ so inc)
    n1 5AC; # CP1(+) ++
    n1 5AF; # CP2(+) ++

##   #fetch next char of each string into W, T
    T T; W W;
@5AC   0  W;  #   : cP1:_ W        #
@5AF   0  T;  #   : cP2:_ T        #

    T   W  ?+3 #   : T W ?+3        # W = *cP2 - *cP1
    Z   Z  ?+3 #   : jmp ?+3        #
    W   Z  5C0 #   : W Z strcmp_continue  # if  W == 0, chars matched, cmp next char
    Z   Z  5E0 #   : Z Z strcmp_neq  # else, string mismatch, try next str


@5C0 #strcmp_continue: #chars matched, keep checking rest of str
   Z Z; #fix Z
   n1 X 5A0 #   : $-1 X loop     # X++, if X<=0, jump strcmp_loop

# stcmp_end_of_loop:
# if we're here, we've successfully matched all the chars
   X X; n1 X; Z Z retsub #return 1

@5E0 #strcmp_neq, return 0
    X X; Z Z retsub



# ================= memcpy
@600 memcpy:
# P1(-) points to src
# P2(-) point to dest
# X(-) holds len to copy
#
# X will hold loop counter (-len)
# W holds fetched char
#
# cSP will hold src ptr
# cD1-3 will hold dest ptr

    # Write ptrs into fetchloop code
    623 623; P1 623;  # cmpSP+ = (P1)
    626 626; P2 626;  # cmpD1+ = (P2)
    627 627; P2 627;  # cmpD2+ = (P2)
    62A 62A; P2 62A;  # cmpD3+ = (P2)
    Z Z 638 #jmp to memcpy check, check first char

@620 memcpy_loop:
       W  W; #Fetch into W
@623   0  W;  #   : cSP:_     W     #
    # Put W into dest
@626   0  0;  #   : cD1:_  cD2:_    #
@629   W  0;  #   :     W  cD3:_    #

    # advance ptrs (+ so inc)
@62C n1 623; # CS1(+) ++
@62F n1 626; # CD1(+) ++
@632 n1 627; # CD2(+) ++
@635 n1 62A; # CD3(+) ++

# memcpy_check
@638  n1 X memcpy_loop #   : $-1 X loop     # X++, if X<=0, jump strcmp_loop

# stcmp_end_of_loop:
# if we're here, we've successfully copied all the chars
    Z Z retsub


# ================================================================
#
#                     CORE FORTH PRIMTIIVES
#
# ================================================================

@800
NEXT_cd: #Sets CWA=*NWA, NWA++, goes to EXECUTE_cd
@800   NWA: 0 Z ;       # fetch from NWA into Z(-)
@803   810 810; Z 810; # flip Z into CWA(+), @810
@809   n1 NWA ; # NWA++
       Z Z 810  # continue (skip some bytes for easier alignment of @s)

@810
EXECUTE_cd: # Executes word at CWA, will continue at NWA
     # fetch CW into jumpPTR (@81B)
       CWA: 0 Z;
@813   81B 81B;
@816   Z 81B ;

# Jump to codeword
@819 Z Z  @81B 0  #jumpPTR @ 81B

# == TEMP DEBUG:
#@819 i1 i2 @81B 0  #jumpPTR @ 81B
#Z Z halt3


@820 do_colon: # Interpreter for forth-words
    # Pushes NWA to return stack
    # Sets NWA = CWA+1
    # jumps NEXT

    # == Push NWA to return stack
    n1 RSP_ ; #grow return stack
    T T; NWA T;
    # GADGET: POKE to RSP
    ?+11 ?+10; RSP_ ?+D; # *(RSP) = -X
    ?+C  ?+B ; RSP_ ?+8; # .
    ?+9  ?+8 ; RSP_ ?+5; # .
    0    0   ; T   0; # .

    NWA NWA;
    CWA Z; Z NWA; n1 NWA; #NWA = CWA+1
    Z Z NEXT_cd;


@879 #calculate this so that exit_wd ends up at 880, for debugging
EXIT_hd: 0 0 4 "EXIT"
@880 EXIT_wd: ?  # Exits a forth-word
    EXIT_cd:
    # Pops NWA from return stack
    Z Z; ?+5 ?+4; RSP_ ?+1; 0 Z; # GADGET:FETCH_NEG
    i1 RSP_; #shrink return stack

    NWA NWA; Z NWA;

    Z Z NEXT_cd; #Jump next


# ====== FORTH PRIMITIVE WORDS

@900 #WORDS

EXECUTE_hd: EXIT_hd 0 7 "EXECUTE"
EXECUTE_wd: ? # ( xt -- ; executes word on TOS, then continues)
    # NWA stays where it was, we'll return to
    # wherever EXECUTE was called from

    # set CWA to TOS (the word to execute)
    CWA CWA; TOS Z; Z CWA; Z Z; #CWA+ = TOS+

    # == Drop execution token (Pop NOS into TOS)
    TOS TOS;
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack
    Z TOS;

    # Jump to EXECUTE_cd
    # this is jumping into NEXT_cd, but after we would have loaded
    # CWA=*NWA and incremented NWA
    # This will execute CWA (xt) and return to NWA
    Z Z EXECUTE_cd


# ================================================================
#
#                  STACK MANIPULATION WORDS
#
# ================================================================
# >R R>
# NOSP@ NOSP!
# DUP DROP 2DROP SWAP OVER 2SWAP ROT -ROT


_toR_hd: EXECUTE_hd 0 2 ">R"
_toR_wd: ? #(pushes from data stack to return stack)
_toR_cd:
    n1 RSP_ ; #grow return stack

    T T; TOS T;
    # GADGET: POKE +TOS to RSP
    ?+11 ?+10; RSP_ ?+D; # *(RSP) = -X
    ?+C  ?+B ; RSP_ ?+8; # .
    ?+9  ?+8 ; RSP_ ?+5; # .
    0    0   ; T   0; # .


    # Drop TOS (NOS->TOS)
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: -@NOSP(Z-)
    TOS TOS; Z TOS; # copy NOS into TOS(+)
    i1 NOSP_; #shrink stack (SP_ goes more negative)

    Z Z NEXT_cd

_fromR_hd: _toR_hd 0 2 "R>"
_fromR_wd: ? # pops from return stack to data stack
_fromR_cd:
    # GADGET: PUSH TOS
    TOS Z ;
    n1 NOSP_; #grow stack (NOSP_ goes closer to 0)
    ?+11 ?+10; NOSP_ ?+D; #
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; Z   0; # .
    #(Z is dirty)

    # POP RSP_ into TOS
    Z Z; ?+5 ?+4; RSP_ ?+1; 0 Z; # GADGET:FETCH_NEG
    i1 RSP_; #shrink return stack
    TOS TOS; Z TOS;

    Z Z NEXT_cd


DUP_hd: _fromR_hd 0 3 "DUP"
DUP_wd: ?
DUP_cd:
    # GADGET: PUSH TOS
    TOS Z ;
    n1 NOSP_; #grow stack (SP_ goes closer to 0)
    ?+11 ?+10; NOSP_ ?+D; #
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; Z   0; # .
    Z Z NEXT_cd

DROP_hd: DUP_hd 0 4 "DROP"
DROP_wd: ?
DROP_cd:
    # GADGET: POP(Z-)
    ?+5 ?+4; NOSP_  ?+1; 0 Z;
    TOS TOS; Z TOS; # copy NOS into TOS(+)
    i1 NOSP_; #shrink stack (SP_ goes more negative)
    Z Z NEXT_cd

_2DROP_hd: DROP_hd 0 5 "2DROP"
_2DROP_wd: ? # drops 2 elements
_2DROP_cd:
    #TOS and NOS can get discarded, but 3OS needs to get popped

    i1 NOSP_; #shrink stack (discard NOS)
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: -@NOSP(Z)
    TOS TOS; Z TOS; # flip Z into TOS+
    i1 NOSP_; #shrink stack (3OS now in TOS)
    Z Z NEXT_cd

SLOW_SWAP_wd: ? # ( a b -- b a )
SLOW_SWAP_cd:
    # GADGET: POPNOS-(Z) (don't change SP)
    ?+5 ?+4; NOSP_  ?+1; 0 Z;

    #Z holds -a
    #TOS holds +b

    T T;     TOS T;
    TOS TOS; Z TOS;

    #TOS holds +a
    #T holds -b

    # GADGET: -!NOS(T) (dont change SP)
    ?+11 ?+10; NOSP_ ?+D; #
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; T   0; # .

    #Swapped
    Z Z NEXT_cd

# We can do better by doing *(NOSP) -= (NOS - TOS)
SWAP_hd: _2DROP_hd 0 4 "SWAP"
SWAP_wd: ? # ( a b -- b a )
SWAP_cd:
    # GADGET: -@NOS(Z) (don't change SP)
    ?+5 ?+4; NOSP_  ?+1; 0 Z;

    #Z holds -a (-NOS)
    #TOS holds +b

    # calculate NOS-TOS
    T T;     TOS T; #T Holds -TOS
    Z T; # T Holds NOS - TOS

    TOS TOS; Z TOS; #TOS holds +a

    #TOS holds +a
    #T holds a-b (NOS-TOS)


    ?+6  ?+5 ; NOSP_ ?+2 ; T 0; # GADGET: SUBNOS(T)
    #Swapped
    Z Z NEXT_cd

OVER_hd: SWAP_hd 0 4 "OVER"
OVER_wd: ? # ( a b -- a b a)
OVER_cd:
    #peek a into Z-
    # GADGET: -@NOS(Z) (don't change SP)
    ?+5 ?+4; NOSP_  ?+1; 0 Z;

    # Push TOS (b) into NOS
    T T; TOS T;
    n1 NOSP_; #grow stack
    ?+11 ?+10; NOSP_ ?+D; # GADGET: -!NOS(T)
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; T   0; # .

    # Put a into TOS
    TOS TOS; Z TOS;
    Z Z NEXT_cd;

_2DUP_hd: OVER_hd 0 4 "2DUP"
_2DUP_wd: do_colon # ( a b -- a b a b) #TODO: upgrade to asm
    OVER_wd OVER_wd EXIT_wd


TUCK_hd: _2DUP_hd 0 4 "TUCK"
TUCK_wd: do_colon # (a b - b a b)
    SWAP_wd OVER_wd EXIT_wd

# We can do better by doing *(NOSP) -= (NOS - TOS)
_2SWAP_hd: TUCK_hd 0 5 "2SWAP"
_2SWAP_wd: ? # ( a b c d -- c d a b )
_2SWAP_cd:

    X X; Y Y; V V;
    # fetch next 3
    ?+5 ?+4; NOSP_  ?+1; 0 V; # GADGET: -@NOS(V)
    i1 NOSP_; #shrink stack (now at 3OS)
    ?+5 ?+4; NOSP_  ?+1; 0 Y; # GADGET: -@NOS(Y)
    i1 NOSP_; #shrink stack (now at 4OS)
    ?+5 ?+4; NOSP_  ?+1; 0 X; # GADGET: -@NOS(X)
    # now  X=-a, Y=-b, V=-c

    # 4OS becomes c, subtract (a-c)
    # 3OS becomes d, subtract (b-d) == (b-tos)
    # NOS becomes a, subtract (c-a)
    # TOS becomes b

    T T; V Z; Z T; #T = -c
    X T; # T = a-c
    ?+6  ?+5 ; NOSP_ ?+2 ; T 0; # GADGET: SUB4OS(T), becomes c

    # need (b-tos)
    Z Z; Y Z; TOS Z; # Z holds (b-tos)
    n1 NOSP_; #grow stack by 1 (now at 3OS)
    ?+6  ?+5 ; NOSP_ ?+2 ; Z 0; # GADGET: SUB4OS(Z), becomes tos == d

    n1 NOSP_; #grow stack by 2 (now at NOS)
    Z Z; T Z; # Z = c-a
    ?+6  ?+5 ; NOSP_ ?+2 ; Z 0; # GADGET: SUBNOS(Z), becomes a

    TOS TOS; Y TOS; # TOS becomes b
    Z Z NEXT_cd

ROT_hd: _2SWAP_hd 0 3 "ROT"
ROT_wd: ? # ( a b tos -- b tos a )
    # Fetch X=-a, Y=-b
    X X; Y Y;
    ?+5 ?+4; NOSP_  ?+1; 0 Y; # GADGET: -@NOS(Y)
    i1 NOSP_; #shrink stack (get to 3OS = a)
    ?+5 ?+4; NOSP_  ?+1; 0 X; # GADGET: -@NOS(X)
    # NOSP points to third-on-stack

    #3os becomes b, subtract (a-b)
    #nos becomes tos, subtract (b-tos)
    # a goes to TOS

    X Y; # Y has (+a - b)
    # NOSP points to third-on-stack
    ?+6  ?+5 ; NOSP_ ?+2 ; Y 0; # GADGET: SUB3OS(Y), 3OS becomes b

    n1 NOSP_; #grow stack, NOSP points to next-on-stack again
    Y Z; TOS Z; # Z has (+b - a - tos)
    X Z; # Z has (b-tos)
    ?+6  ?+5 ; NOSP_ ?+2 ; Z 0; # GADGET: SUBNOS(Z), NOS becomes tos

    TOS TOS; X TOS; #TOS becomes a
    Z Z NEXT_cd

_ROT_hd: ROT_hd 0  4 "-ROT"
_ROT_wd: ? # ( a b tos -- tos a b )
    # Fetch X=-a, Y=-b
    X X; Y Y;
    ?+5 ?+4; NOSP_  ?+1; 0 Y; # GADGET: -@NOS(Y)
    i1 NOSP_; #shrink stack (get to 3OS = a)
    ?+5 ?+4; NOSP_  ?+1; 0 X; # GADGET: -@NOS(X)
    # NOSP points to third-on-stack

    #3os becomes tos, subtract (a-tos)
    #nos becomes a, subtract (b-a)
    #tos becomes b

    X Z; TOS Z; # Z has (a - tos)
    # NOSP points to third-on-stack
    ?+6  ?+5 ; NOSP_ ?+2 ; Z 0; # GADGET: SUB3OS(Z), 3OS becomes tos

    Y X; # X has (b-a)
    n1 NOSP_; #grow stack, NOSP points to next-on-stack again
    ?+6  ?+5 ; NOSP_ ?+2 ; X 0; # GADGET: SUBNOS(X), NOS becomes a

    TOS TOS; Y TOS; #TOS becomes b
    Z Z NEXT_cd

PICK_hd: _ROT_hd 0 4 "PICK"
PICK_wd: ? # ( ... s2 s1 s0 n -- ... s2 s1 s0 s_n )
    # n is in TOS(+)
    # if n == 0, we want to read NOSP[0]
    # for n > 0, we want to go deeper into the stack (higher in mem)

    TOS NOSP_; # NOSP(-) -= n (go towards higher memory addresses, deeper)

    ### fetch NOSP+n into T-
    T T;
    ?+5 ?+4; NOSP_  ?+1; 0 T; # GADGET: @NEGNOS(Z)

    TOS Z; Z NOSP_; # NOSP(-) += n (return to normal)

    # put fetched val in TOS
    TOS TOS; T TOS;

    Z Z NEXT_cd

# ================================================================
#
#                       VARS / CONSTS
#
# ================================================================
# Lost words: do_var, do_const
# BASE STATE DP LATEST
# DO_COLON DO_VAR DO_CONST
# DS0 RS0 NOSP_ RSP_
# TOK_BUFF TOKP

do_var: # push CWA+1
    ### Push TOS into NOS
    T T; TOS T;
    n1 NOSP_; #grow stack
    ?+11 ?+10; NOSP_ ?+D; # GADGET: NEG!NOS(T)
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; T   0; # .

    TOS TOS; CWA Z; Z TOS; n1 TOS; # TOS = CWA+1
    Z Z NEXT_cd

do_const: # push *(CWA+1)
    ### Push TOS into NOS
    T T; TOS T;
    n1 NOSP_; #grow stack
    ?+11 ?+10; NOSP_ ?+D; # GADGET: NEG!NOS(T)
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; T   0; # .

    #ptr(-) in P1
    P1 P1; CWA P1; i1 P1; # P1(-) points to CWA+1
    ?+5 ?+4; P1 ?+1; 0 Z; # GADGET:FETCH Z -= *(-P1)
    TOS TOS; Z TOS;

    Z Z NEXT_cd

# Outer interp vars
BASE_hd: PICK_hd 0 4 "BASE"
BASE_wd:  do_var    BASE_val: 0A
STATE_hd: BASE_hd 0 5 "STATE"
STATE_wd: do_var    STATE_val: 0

# Dict vars
DP_hd: STATE_hd 0 2 "DP"
DP_wd:     do_var       DP_val:    0DEAD #TODO
LATEST_hd: DP_hd 0 6 "LATEST"
LATEST_wd: do_var       LATEST_val: 0DEAD

# Constant, key addresses of lost interpreters
# (others can be gotten using find)
DO_COLON_hd: LATEST_hd 0 8 "DO_COLON"
DO_COLON_wd: do_const       DO_COLON_val: do_colon
DO_VAR_hd: DO_COLON_hd 0 6 "DO_VAR"
DO_VAR_wd:   do_const       do_var
DO_CONST_hd: DO_VAR_hd 0 8 "DO_CONST"
DO_CONST_wd: do_const       do_const

#DO_EXIT_wd: do_const       DO_EXIT_val: EXIT_cd


# Note: when stack is empty, NOSP(-) points to DS0+2
# Note: when stack is empty, RSP(-) points to DS0+1
DS0_hd: DO_CONST_hd 0 3 "DS0"
DS0_wd: do_const  DS0_val: dstack_base

RS0_hd: DS0_hd 0 3 "RS0"
RS0_wd: do_const  RS0_val: rstack_base

NOSP__hd: RS0_hd 0 5 "NOSP_"
NOSP__wd: do_const  NOSP__val: NOSP_

RSP__hd: NOSP__hd 0 4 "RSP_"
RSP__wd:  do_const   RSP__val: RSP_



# TOKEN buffer (note: TOK_BUFF_0 is len, rest is string)
# TOKP points to next free space?
TOK_BUFF_hd: RSP__hd 0 8 "TOK_BUFF"
TOK_BUFF_wd: do_const TOK_BUFF_val: token_buff

TOKP_hd: TOK_BUFF_hd 0 4 "TOKP"
TOKP_wd:     do_var   TOKP_val: 0


restart_wd_addr: 0DEAD # Init will fill this in, since we don't have forward lebels

# Other Vars:
# LATEST (defined just before main loop, since is end of dict)

# ================================================================
#
#                   LOST WORDS
#
# ================================================================
# Defines: (LIT, LITSTR)
# LW_LIT LW_LITSTR LW_EXIT

# Reads from NWA, pushes to stack, advances NWA
LIT_wd: ?
LIT_cd:
    # GADGET: PUSH TOS into stack
    TOS Z ;
    n1 NOSP_; #grow stack (SP_ goes closer to 0)
    ?+11 ?+10; NOSP_ ?+D; #
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; Z   0; # .

    Z Z ;

    # Fetch from NWA
    T T; NWA T; #put -ptr into T
    # Fetch(-) into Z
    ?+5 ?+4;        T   ?+1; 0  Z;  # Z = -*(-T)
    TOS TOS; Z TOS; #TOS gets (+) *NWA

    # Increment NWA
    n1 NWA ;

    Z Z NEXT_cd

# String starting at NWA. Pushes strp to stack
# Advances NWA by len+1 to skip string
LITSTR_wd: ?
    # GADGET: PUSH TOS into stack
    TOS Z ;
    n1 NOSP_; #grow stack (SP_ goes closer to 0)
    ?+11 ?+10; NOSP_ ?+D; #
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; Z   0; # .

    Z Z;

    # Copy strp (NWA) to TOS
    T T; NWA T; TOS TOS; T TOS;

    # Fetch strlen from NWA (T- is PTR)
    ?+5 ?+4;        T   ?+1; 0  Z;  # Z = -*(-T)
    # Z holds -strlen

    # increment NWA by strlen + 1
    Z NWA; n1 NWA;

    Z Z NEXT_cd


LW_LIT_hd: TOKP_hd 0  6 "LW_LIT"
LW_LIT_wd: do_const LIT_wd

LW_LITSTR_hd: LW_LIT_hd 0  9 "LW_LITSTR"
LW_LITSTR_wd: do_const LITSTR_wd

LW_EXIT_hd: LW_LITSTR_hd 0 7 "LW_EXIT"
LW_EXIT_wd: do_const EXIT_wd

# ================================================================
#
#                    ARITHMETIC
#
# ================================================================
# @ ! +! -!
# + - NEG 1+ 2+ 1- 2-
# CSPLIT CJOIN
# * /MOD
# TODO 2* >> << AND OR NOT


_at_hd: LW_EXIT_hd 0 1 "@"
_at_wd: ? # ( addr - *addr )
_at_cd:
    P1 P1; TOS P1; # P1(-) = addr

    # Fetch(-) into Z
    ?+5 ?+4;        P1   ?+1; 0  Z;  # Z = -*(-P1)
    TOS TOS; Z TOS; #TOS gets (+)

    Z Z NEXT_cd

_bang_hd: _at_hd 0 1 "!"
_bang_wd: ? # (val addr - [*addr = val] )

    P1 P1; TOS P1; # addr in P1(-)

    X X; # Pop val(-) into X
    ?+5 ?+4; NOSP_  ?+1; 0 X; # GADGET: POP(X-)
    i1 NOSP_; #shrink stack (SP_ goes more negative)

    # Pop 3OS into TOS
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: POP(Z-)
    i1 NOSP_; #shrink stack (SP_ goes more negative)
    TOS TOS; Z TOS;

    # POKE value into ptr
    # GADGET: POKE:
    ?+11 ?+10; P1 ?+D; # *(P1-) = -X
    ?+C  ?+B ; P1 ?+8; # .
    ?+9  ?+8 ; P1 ?+5; # .
    0    0   ; X   0; # .
    Z Z NEXT_cd

_plusbang_hd: _bang_hd 0 2 "+!"
_plusbang_wd: ? # (val addr - [*addr += val] )

    P1 P1; TOS P1; # addr in P1(-)

    X X; # Pop val(-) into X
    ?+5 ?+4; NOSP_  ?+1; 0 X; # GADGET: POP(X-)
    i1 NOSP_; #shrink stack (SP_ goes more negative)

    # Pop 3OS into TOS
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: POP(Z-)
    i1 NOSP_; #shrink stack (SP_ goes more negative)
    TOS TOS; Z TOS;

    # POKESUB X(-) into ptr  ( += val )
    ?+6  ?+5 ; P1 ?+2 ; X 0; # GADGET: POKESUB(P1), *(-P1) -= X

    Z Z NEXT_cd

_minusbang_hd: _plusbang_hd 0 2 "-!"
_minusbang_wd: ? # (val addr - [*addr -= val] )
    P1 P1; TOS P1; # addr in P1(-)

    X X; # Pop val(-) into X
    ?+5 ?+4; NOSP_  ?+1; 0 X; # GADGET: POP(X-)
    i1 NOSP_; #shrink stack (SP_ goes more negative)

    # Pop 3OS into TOS
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: POP(Z-)
    i1 NOSP_; #shrink stack (SP_ goes more negative)
    TOS TOS; Z TOS;

    #flip X,  Z(+) = val
    Z Z; X Z;
    # POKESUB Z(+) into ptr  ( *ptr -= val )
    ?+6  ?+5 ; P1 ?+2 ; Z 0; # GADGET: POKESUB(P1), *(-P1) -= Z

    Z Z NEXT_cd

_plus_hd: _minusbang_hd 0 1 "+"
_plus_wd: ? #( a b -- a+b)
    # ### Pop NOS into Z
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    Z TOS; # TOS -= -a
    Z Z NEXT_cd

_minus_hd: _plus_hd 0 1 "-"
_minus_wd: ? #( a b -- a-b)
    # ### Pop NOS into Z
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    # Z holds -a

    T T; TOS T; T Z; # Z holds b-a
    TOS TOS; Z TOS; # TOS holds a-b
    Z Z NEXT_cd

NEG_hd: _minus_hd 0 3 "NEG"
NEG_wd: ? #( a -- -a)
    T T;
    TOS T; T Z;
    TOS TOS; Z TOS;
    Z Z NEXT_cd

_1plus_hd: NEG_hd 0 2 "1+"
_1plus_wd: ? #( a -- a+1)
    n1 TOS; Z Z NEXT_cd

_2plus_hd: _1plus_hd 0 2 "2+"
_2plus_wd: ? #( a -- a+2)
    n2 TOS; Z Z NEXT_cd

_1minus_hd: _2plus_hd 0 2 "1-"
_1minus_wd: ? #( a -- a-1)
    i1 TOS; Z Z NEXT_cd

_2minus_hd: _1minus_hd 0 2 "2-"
_2minus_wd: ? #( a -- a-2)
    i2 TOS; Z Z NEXT_cd


# ============= BITWISE STUFF

# splits word into 2 bytes, LE on top
CSPLIT_hd: _2minus_hd 0 6 "CSPLIT"
CSPLIT_wd: ? # ( x -- hibyte(x) lobyte(x))
    alu_A alu_A;   TOS Z; Z alu_A; Z Z;  # alu_A := x

    # Get hibyte:
    alu_B alu_B;  n8 alu_B;  # alu_B := 8
    T T; alu_rs T;    # T- = (x >> 8)

    # Push hibyte into NOS
    n1 NOSP_; #grow stack
    ?+11 ?+10; NOSP_ ?+D; # GADGET: NEG!NOS(T)
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; T   0; # .

    # Get lobyte into TOS
    TOS TOS;
    alu_B alu_B;  nF0 alu_B; nF alu_B;  # alu_B := FF
    alu_and Z; Z TOS;                   # TOS = (x & FF)

    Z Z NEXT_cd

# Undoes CSPLIT
CJOIN_hd: CSPLIT_hd 0 5 "CJOIN"
CJOIN_wd: ? # ( hibyte lobyte -- x )

    # ### Pop NOS(hibyte) into Z
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    alu_A alu_A; Z alu_A; Z Z;  # alu_A := hibyte(+)

    # Shift hibyte up
    alu_B alu_B;  n8 alu_B;  # alu_B := 8
    T T; alu_ls T;    # T- = (x << 8)

    # add hibyte into TOS
    T TOS ;

    Z Z NEXT_cd


_times_exit: # We jump here once X==0
    # NOTE: Z was clobbered before jump
    TOS TOS; V Z; Z TOS; # Result in V(+), copy to T
    Z Z NEXT_cd

# ================== TIMES ENTRY POINT
_times_hd: CJOIN_hd 0 1 "*"
_times_wd: ? # (x y - x*y )

    alu_B alu_B; n1 alu_B; # alu_B is always 1

    # X and Y hold negatives, so ALU holds positives
    X X ;  # X(-) holds A,
    Y Y ;  TOS Y; # Y(-) holds B
    V V; # Sum(+) in V

    # Pop val(-) into X
    ?+5 ?+4; NOSP_  ?+1; 0 X; # GADGET: POP(X-)
    i1 NOSP_; #shrink stack (SP_ goes more negative)

_times_loop:
    alu_A alu_A; X alu_A; # alu(+) gets A

#==== if X & 1, SUM += Y
    T T; alu_and T ; # T = -(A&1)
    T Z ?+3 # if A&1 <= 0, skip

    Y V ; # else A&1 == 1, SUM(+) -= Y(-), add val to SUM
    Z Z ; # unclobber Z

#==== X >> 1, Y<<1
    X X; alu_rs X; # X(-) = a>>1,

    alu_A alu_A; Y alu_A; # alu(+) gets Y(-)
    Y Y; alu_ls Y; # Y(-) = b<<1

#==== if X == 0, exit
    Z X ?+3         # if     X<= 0, nextif
    Z Z ?+3         # else   X > 0, skip
    X Z _times_exit # nextif X >= 0, so x == 0, so exit
                    # else   x <> 0
    Z Z _times_loop
# else, jump loop:


_divmod_exit: # We jump here once X==0
    # W = 0
    # X = remainder
    # V(-) = quotient
    # Y would be divisor>>1, but we exited early


    # TODO: if P1, flip V, X
    # P1 is -1, 0, or +1. 0 means no flip needed

    # if p1 > 0, p1 -= 2
    Z P1 ?+3    #if P1 <= 0, skip
    i2 P1 ; # else (P1>0), P1-=2
    # Now P1 is 0(noflip) or -1 (flip)

    n1 P1 ; # Now is 1(noflip) or 0(flip)

    #Quotient in V(-), Remainder in X(+)

    Z P1 ?+3 # If P1=0 (flip)
    Z Z ?+0F # else, skip
        T T; V Z; Z T; V V; T V; Z Z;  # Flip V

    # ### Push quotient (in V(-))  into NOS
    n1 NOSP_; #grow stack
    ?+11 ?+10; NOSP_ ?+D; # GADGET: NEG!NOS(T)
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; V   0; # .


    # Remainder in X(+)
    Z P1 ?+3 # If P1=0 (flip, Copy X-)
    Z Z ?+09 # else, skip, copy X+
        TOS TOS; X TOS; # Flip X, so Copy X- to TOS
        Z Z NEXT_cd
    # else
        TOS TOS; X Z; Z TOS; # Remainder in X(+), copy to TOS
        Z Z NEXT_cd

# ================ DIVMOD ENTRY POINT
_divmod_hd: _times_hd 0 4 "/MOD"
_divmod_wd: ? # (x y - x/y x%y )

    alu_B alu_B; n1 alu_B; # alu_B is always 1

    # TODO: can optimize by assigning flipped X&Y, since
    # we explicitly handle their signs anyway

    # X and Y hold positives,
    X X ;  # X holds A (remainder),
    Y Y ; T T; TOS T; T Y; # Y holds B (divisor)
    V V ; # Quotient(-) in V
    W W; n1 W; # multiplier, starts at 1

    P1 P1; # P1 will hold sign bit, = +1/-1 if negative, 0 if positive

    # Flip Y to positive, if Y == 0, error out?
    Z Y ?+3 # if Y <= 0: nextif
    Z Z ?+12 # else Y>0: continue to endif (6 ops, 18words)
    Y Z halt5 # nextif Y>=0 (Y==0) halt5, divide by 0
    # nextelse: Y < 0: flip Y,
        Y Y; T T; Z T; T Y; i1 P1; #flip Y, P1--
    # endif
    Z Z ;

    # Pop val(+) into X
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: POP(Z-)
    Z X; Z Z;
    i1 NOSP_; #shrink stack (SP_ goes more negative)


    # Flip X to positive, flip sign bit
    X Z ?+0F #if X >= 0 skip (5ops, 15words=0x0F)
    # else: X < 0
        X X; T T; Z T; T X; n1 P1; #P1++
    #endif
    Z Z ;



    # Lshift Y and multiplier until they hit the left side (<0)
    # actually, only need to shift until Y >= X
    # then Y-X >= 0, and won't overflow!
    # Proof (consider 4bit)
    #  X = 0b0111, Y = 0b0111, match, wont shift higher
    #  X = 0b0111, Y = 0b0110, shifts up
    #              Y = 0b1100, match, difference is 3, 0b0011
    #  X = 0b0100, Y = 0b0011, shifts up
    #              Y = 0b0110, match, difference is 2, 0b0010
    #  X = 0b0101, Y = 0b0100, shifts up
    #              Y = 0b1000, match, difference is 4, 0b0100
    #
_divmod_loop1:
    # if Y >= X, break
    Q1 Q1; Y Q1; # temp: Q1 = -Y
    T T; X T; Q1 T; # T = Y-X
    T Z ?+1B # if X-Y<=0 (Y>=X), break


    #else: double Y, double mult
    Z Z; Y Y; Q1 Y; Q1 Y; #12 words
    W Z; W W; Z W; Z W; Z Z _divmod_loop1 # 15 words, total 27 = 0x1B

    # endloop
    Z Z;

    # Now: since we've guaranteed both X and Y originally >0, Y wont have overflowed.
    # Y may be negative, but Y-X >= 0

    alu_B alu_B; n1 alu_B; # Always shifting by 1

_divmod_loop2:
    #if Y <= X (Y-X <= 0)
    #  X -= Y
    #  Quot+= mult

    Y X; X Z ?+C # X-=Y; if result >= 0 (i.e. Y was <= X), if succeeds
        T T; Y T; T X;  # else, undo that
        Z Z ?+6         # skip to endif
    # (if succeeded)
        Z Z; W V; # Quotient(-) += Mult
    # endif

    # Y >> 1, mult >> 1
    # NOTE: if W<=0, exit
    #          W can't be negative, since we have rightshifted it at least once
    #          therefore we exit once it hits 0
    T T; alu_A alu_A; W T; T alu_A; W W; T T; alu_ars T; T W _divmod_exit
    T T; alu_A alu_A; Y T; T alu_A; Y Y;      alu_ars Z; Z Y;
    Z Z _divmod_loop2




#==== if X & 1, SUM += Y
    T T; alu_and T ; # T = -(A&1)
    T Z ?+3 # if A&1 <= 0, skip

    Y V ; # else A&1 == 1, SUM(+) -= Y(-), add val to SUM
    Z Z ; # unclobber Z

#==== X >> 1, Y<<1
    X X; alu_rs X; # X(-) = a>>1,

    alu_A alu_A; Y alu_A; # alu(+) gets Y(-)
    Y Y; alu_ls Y; # Y(-) = b<<1

#==== if X == 0, exit
    Z X ?+3         # if     X<= 0, nextif
    Z Z ?+3         # else   X > 0, skip
    X Z _divmod_exit # nextif X >= 0, so x == 0, so exit
                    # else   x <> 0
    Z Z _divmod_loop2
# else, jump loop:

# ================================================================
#
#                        CONTROL FLOW
#
# ================================================================
# = <> < >=
# 0= 0<> 0> 0<= 0<
# <= >
# ( BRANCH 0BRANCH )
# LW_BRANCH LW_0BRANCH

# NOTE: All comparisons fall through to their 0 versions, therefore their
# headers are separate and point to the code bodies

_eq_hd: _divmod_hd 0 1 "="
_eq_wd: ? # ( a b  -  a==b?1:0)
    # ### Pop NOS, subtract from TOS
    ?+5 ?+4; NOSP_  ?+1; 0 TOS; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    #TOS is b-a, fallthru to 0eq
_0eq_cd:
    Z TOS ?+3 # if     TOS <= 0, nextif
    Z   Z ?+3 # else   TOS > 0, skip
    TOS Z ?+6 # nextif TOS >= 0, so TOS == 0, so jmp to ==0
    # >0 or <0
        TOS TOS;
        Z Z NEXT_cd
    # ==0:
        n1 TOS; #TOS = 1
        Z Z NEXT_cd



_ne_hd: _eq_hd 0 2 "<>"
_ne_wd: ? # ( a b  -  a!=b?1:0)
    # ### Pop NOS, subtract from TOS
    ?+5 ?+4; NOSP_  ?+1; 0 TOS; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    #TOS is b-a
_0ne_cd:
    Z TOS ?+3 # if     TOS <= 0, nextif
    Z   Z ?+3 # else   TOS > 0, skip
    TOS Z ?+9 # nextif TOS >= 0, so TOS == 0, so jmp to ==0
    # >0 or <0
        TOS TOS; n1 TOS; #TOS = 1
        Z Z NEXT_cd
    # ==0:
        #TOS is already 0
        Z Z NEXT_cd



_lt_hd: _ne_hd 0 1 "<"
_lt_wd: ? # ( a b  -  a<b?1:0)
    # ### Pop NOS, subtract from TOS
    ?+5 ?+4; NOSP_  ?+1; 0 TOS; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    #TOS is b-a
_0gt_cd: # for 0-comparison, TOS is a-0, so is gt instead of lt

    # a<b iff b-a>0
    Z TOS ?+3 # if     b-a <= 0, b<=a nextif
    Z   Z ?+6 # else   b-a > 0 , b > a skip
    # b <= a
        TOS TOS; #TOS = 0
        Z Z NEXT_cd
    # b > a
        TOS TOS; n1 TOS; #TOS = 1
        Z Z NEXT_cd

_ge_hd: _lt_hd 0 2 ">="
_ge_wd: ? # ( a b  -  a>=b?1:0)
    # ### Pop NOS, subtract from TOS
    ?+5 ?+4; NOSP_  ?+1; 0 TOS; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    #TOS is b-a

_0le_cd: # for 0-comparison, TOS is a-0, so is le instead of ge
    # a>=b iff b-a<=0
    Z TOS ?+3 # if     b-a <= 0, b<=a nextif
    Z   Z ?+9 # else   b-a > 0 , b > a skip
    # b <= a
        TOS TOS; n1 TOS; #TOS = 1
        Z Z NEXT_cd
    # b > a
        TOS TOS; #TOS = 0
        Z Z NEXT_cd



# 0-comparisons are fallthroughs of the main paths, so write their headers here
# TODO: HEADERS
_0eq_hd: _ge_hd 0 2 "0="
_0eq_wd: _0eq_cd

_0ne_hd: _0eq_hd 0 3 "0<>"
_0ne_wd: _0ne_cd

# = link up
_0gt_hd: _0ne_hd 0 2 "0>"
_0gt_wd: _0gt_cd

_0le_hd: _0gt_hd 0 3 "0<="
_0le_wd: _0le_cd

# Define in reference to the above (this is slower, but safer)
_0ge_hd: _0le_hd 0 3 "0>="
_0ge_wd: ?
    T T; TOS T; T Z; TOS TOS; Z TOS; Z Z _0le_cd

_0lt_hd: _0ge_hd 0 2 "0<"
_0lt_wd: ?
    T T; TOS T; T Z; TOS TOS; Z TOS; Z Z _0gt_cd

_le_hd: _0lt_hd 0 2 "<="
_le_wd: do_colon
    SWAP_wd _ge_wd EXIT_wd

_gt_hd: _le_hd 0 1 ">"
_gt_wd: do_colon
    SWAP_wd _lt_wd EXIT_wd


BRANCH_wd: ? # NWA += *(NWA)
BRANCH_cd:
    #ptr(-) in P1
    P1 P1; NWA P1; # P1(-) points to NWA
    ?+5 ?+4; P1 ?+1; 0 Z; # GADGET:FETCH Z -= *(-P1)

    # Z = -offset
    Z NWA; # NWA += offset;
    Z Z NEXT_cd

_0BRANCH_wd: ? # If 0, jump BRANCH_cd
    ### Pop NOS into Z
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    T T; TOS T; #TOS in T(-)

    TOS TOS; Z TOS; #NOS+ into TOS

    Z Z;
    Z T ?+3 #if T <= 0; goto nextif
    Z Z ?+3 #else: T>0, no branch
    T Z ?+6 #nextif T>=0 (T==0): jump to take_branch

    #Else: no branch, step over offset
    n1 NWA;
    Z Z NEXT_cd

    # take_branch:
    Z Z BRANCH_cd #(need extra op to clear Z)

# Add constants to capture BRANCH and 0BRANCH
LW_BRANCH_hd: _gt_hd 0  9 "LW_BRANCH"
LW_BRANCH_wd: do_const BRANCH_wd

LW_0BRANCH_hd: LW_BRANCH_hd 0 0A "LW_0BRANCH"
LW_0BRANCH_wd: do_const _0BRANCH_wd

# ================================================================
#
#                        I/O and STRINGS
#
# ================================================================
# KEY EMIT SPACE NL
# TOKEN
# STRCHARS STR= TELL
# MEMCPY STRCPY
# DIGIT NUMBER


KEY_hd: LW_0BRANCH_hd 0 3 "KEY"
KEY_wd: ? # Fetches in a char (buffers through C_)
    # IF EOF, halts

    ### Push TOS into NOS
    T T; TOS T;
    n1 NOSP_; #grow stack
    ?+11 ?+10; NOSP_ ?+D; # GADGET: NEG!NOS(T)
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; T   0; # .

    # We might have pushed back a character previously, check for that
    Z C_needs_fetch ?+6
        C_ C_; IN C_;  # if needs_fetch=1, fetch a fresh char
    # Else, use the one from C_

    # Put char into TOS
    TOS TOS; C_ TOS;

    # Mark needs_fetch=1, since we consumed the char from it
    C_needs_fetch C_needs_fetch;
    n1 C_needs_fetch ; #needs_fetch=1

    # check for EOF (<0)
    n1 TOS haltE #if TOS+1 <= 0, char was -1
    i1 TOS;        #else, decrement it back

    Z Z NEXT_cd


EMIT_hd: KEY_hd 0 4 "EMIT"
EMIT_wd: ? #Emits char at TOS
EMIT_cd:
    T T; TOS T; T OUT;

    # GADGET: POP(Z-)
    ?+5 ?+4; NOSP_  ?+1; 0 Z;
    TOS TOS; Z TOS; # copy NOS into TOS(+)
    i1 NOSP_; #shrink stack (SP_ goes more negative)

    Z Z NEXT_cd;

SPACE_hd: EMIT_hd 0 5 "SPACE"
SPACE_wd: ?  # Emits 0x20 ' '
SPACE_cd:
    n20 OUT; Z Z NEXT_cd

NL_hd: SPACE_hd 0 2 "NL"
NL_wd: ?  # Emits 0xA '\n'
NL_cd:
    nA OUT; Z Z NEXT_cd

HALT1_wd: ?
HALT1_cd:
    0 0 halt1



# NOTE: token buffers/ptrs with VARS/CONSTS

# VARS:
# TOKP resets to TOK_BUFF
#  VARS
#  Y(-) holds len
#  P1(-) pts to next free space for char, (starts at TOK_BUFF)
#  fetch char into X


# Reached EOF, halt
TOKEN_cd_eof: Z Z haltE

# Skip comments until we hit \n?
TOKEN_cd_comment: #TODO
    Z Z halt6






TOKEN_cd_end:
    # We've poked all our chars in
    # Write TOKP
    TOKP_val TOKP_val; P1 TOKP_val;

    # Write len to token_buff[0] (Y is (-))
    token_buff token_buff; Y token_buff;

    #=== Return (token_buff -- )

    ### Push TOS into NOS
    T T; TOS T;
    n1 NOSP_; #grow stack
    ?+11 ?+10; NOSP_ ?+D; # GADGET: NEG!NOS(T)
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; T   0; # .

    # Put addr of token_buff into TOS
    TOS TOS; TOK_BUFF_val Z; Z TOS;
    Z Z NEXT_cd #EXIT



# We got a token starting with \n
# Push just that token, then return thru TOKEN_cd_end
# mark C_needs_fetch=1, since we don't keep the \n
TOKEN_cd_newline:
    # Poke into string pointer at P1
    # GADGET: POKE-:
    ?+11 ?+10; P1 ?+D; # *(P-) = -C(-)
    ?+C  ?+B ; P1 ?+8; # .
    ?+9  ?+8 ; P1 ?+5; # .
    0    0   ; C_   0; # .

    # Note: we don't want to keep the \n for next time,
    C_needs_fetch C_needs_fetch;
    n1 C_needs_fetch ; #needs_fetch=1
    C_ C_;

    i1 Y;  # inc length (-)
    i1 P1; # advance ptr P1(-)

    Z Z TOKEN_cd_end

# We finished reading a normal token that ended with a separator
# We want to push back the separator for later use,
# then return thru CD_end
TOKEN_cd_endtoken:

    # The last separator char is in C_,
    # mark needs_fetch=0
    C_needs_fetch C_needs_fetch TOKEN_cd_end




# We've skipped all the preceding blanks, now go grab the actual token
TOKEN_cd_readchars:
    #Got a token char in C_, push it to the str

    # Poke into string pointer at P1
    # GADGET: POKE-:
    ?+11 ?+10; P1 ?+D; # *(P-) = -C(-)
    ?+C  ?+B ; P1 ?+8; # .
    ?+9  ?+8 ; P1 ?+5; # .
    0    0   ; C_   0; # .

    i1 P1; # advance ptr P1(-)
    i1 Y;  # inc length (-)

    # just pushed C_, get next char
    C_ C_; IN C_;
    X X; C_ X; # X(+) = C(-)

    # Test value by repeatedly subtracting and testing <= 0
    # - Keep grabbing chars until we hit a space or \n
    n1  X TOKEN_cd_eof        #  : $-1 X halt eof            # char <= -1, == EOF
    i1  X  ?                  #  : $1  X                     #
    i20 X TOKEN_cd_endtoken   #  : $20 X end                 # <=20, ' ' or \n or nonprint
    Z   Z TOKEN_cd_readchars  #  :                           # >20, poke it in, continue


# =============== TOKEN ENTRY POINT (need to jump backwards for labels to work)
TOKEN_hd: NL_hd 0 5 "TOKEN"
TOKEN_wd: ? # Reads a token from IN
            # Skips blanks and control characters
            # Once finds a text char, consume that until next blank, read into tok_buff
            # return strp

    Y Y; # len(-) = 0
    P1 P1; TOK_BUFF_val P1; i1 P1; #P1 points to token_buff[1] (first string char)

    # Loop, repeatedly skipping comments and blanks until we find a char

    # NOTE: Between invocations of TOKEN, we might have pushed back a char
    # - After this point, C_ will be valid
    # - MAKE SURE we set C_needs_fetch correctly when we exit TOKEN
    Z C_needs_fetch ?+6  # If !needs_fetch, skip fetching
TOKEN_cd_lstrip:
    C_ C_; IN C_; # Get next char (skip first time)

    #First copy it into X(+)
    X X; C_ X; # X(+) = C(-)

    # Test value by repeatedly subtracting and testing <= 0
    # - discard all leading spaces
    # - if we get a newline before any token chars, special case it
    # - otherwise go to normal token parsing
    n1  X TOKEN_cd_eof        #  : $-1 X haltEOF             # char <= -1, == EOF
    i1  X  ?                  #  : $1  X                     # ( undo -1 )
    i8  X TOKEN_cd_readchars  #  : $8  X default             # <=08,
    i1  X TOKEN_cd_lstrip     #  : $1  X default             # <=09, '\t'
    i1  X TOKEN_cd_newline    #  : $10 X newline             # <=0A, '\n'
    i10 X  ?                  #                              #  (1A)
    i5  X TOKEN_cd_readchars  #  : $5  X default             # <=1F,
    i1  X TOKEN_cd_lstrip     #  : $1  X skip_spaces         # <=20, ' '
     Z  Z TOKEN_cd_readchars  #  :  Z  Z default             # >20

    #shouldn't reach here
    0d 0d 0d


# TOKEN:
# skips ' ', '\t', '\n'
# consumes chars until blank

STRCHARS_hd: TOKEN_hd 0 8 "STRCHARS"
STRCHARS_wd: do_colon # (strp -- -1 [all chars of string, first char on TOS] )
    LIT_wd 0FFFF SWAP_wd # Push flag ( -1 strp )

    #Get len
    DUP_wd _at_wd SWAP_wd #(-1 len strp)

    #Start at last char, strp+len (don't need to -1 since str[0] is len field)
    OVER_wd _plus_wd  # (-1 len strp_end)
    SWAP_wd #(-1 strp_end len)

    # loop:
    DUP_wd _0BRANCH_wd 0A  #if len = 0, exit (jump dec10)

    # ( -1 [chars] strp len)
    SWAP_wd DUP_wd _at_wd _ROT_wd #( -1 [chars+1] len strp )

    _1minus_wd SWAP_wd _1minus_wd #( -1 [chars+1] strp-1 len-1 )

    BRANCH_wd 0FFF5 #loop (-dec11)
    # endloop

    _2DROP_wd # drop pointers
    EXIT_wd


TELL_hd: STRCHARS_hd 0 4 "TELL"
TELL_wd: do_colon # (strp - [prints string])
    STRCHARS_wd

    #loop
    DUP_wd _0ge_wd _0BRANCH_wd 4    #if ! >=0, , end of string, exit
    EMIT_wd BRANCH_wd 0FFFA #else emit, loop -6
    #endloop
    DROP_wd #drop the -1
    EXIT_wd


STR_eq_hd: TELL_hd 0 4 "STR="
STR_eq_wd: ? # (strp strp - ?equal)

    P1 P1; P2 P2;

    # Copy TOS into P1(-)
    P1 P1; TOS P1;

    # Pop NOS into P2(-1)
    ?+5 ?+4; NOSP_  ?+1; 0 P2; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    R R; ?+5 R; Z Z strcmp   ? #JSR

    # Result in X, copy to TOS
    TOS TOS; X Z; Z TOS;

    Z Z NEXT_cd



MEMCPY_hd: STR_eq_hd 0 6 "MEMCPY"
MEMCPY_wd: ? # (len src dst --)
# Copies len bytes from src to dst, moving upwards
    # copy TOS(destp) into P2(-)
    P2 P2; TOS P2;

    ### Pop NOS(srcp) into P1
    P1 P1;
    ?+5 ?+4; NOSP_  ?+1; 0 P1; # GADGET: @NEGNOS(P1)
    i1 NOSP_; #shrink stack

    ### Pop 3OS(len) into X(-)
    X X;
    ?+5 ?+4; NOSP_  ?+1; 0 X; # GADGET: @NEGNOS(X)
    i1 NOSP_; #shrink stack

    ### Pop 4OS() into TOS
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: @NEGNOS(X)
    i1 NOSP_; #shrink stack
    TOS TOS; Z TOS; Z Z;

    #jsr memcpy(len, src, dest) (return to NEXT_cd)
    R R; ?+5 R; Z Z memcpy   NEXT_cd #JSR

STRCPY_hd: MEMCPY_hd 0 6 "STRCPY"
STRCPY_wd: do_colon # (src_strp destp -- ) copies string from src to dest
    OVER_wd _at_wd # (src_strp destp len)
    _1plus_wd # We want to copy len+1 words
    _ROT_wd #bury the len field (len srcp destp)
    MEMCPY_wd EXIT_wd


DIGIT_cd_inval: #invalid character, return FF
    TOS TOS; nF0 TOS; nF TOS;
    Z Z NEXT_cd;

DIGIT_cd_az:
    # X holds char-'z' or char-'Z'
    # 'Z' should be dec35, 'A' should be dec10
    # Add dec35 (0x23),
    n20 X; n3 X;
    # Fall through to numdigit return
    Z Z ?+3

DIGIT_cd_09:
    # X holds char-'9'
    # Add 9, so '9' should be 9, '0' should be 0
    n9 X;
    TOS TOS; X Z; Z TOS;
    Z Z NEXT_cd;


DIGIT_hd: STRCPY_hd 0 5 "DIGIT"
    # Parses an ascii character into a digit
    # if char not in range [0-9a-zA-Z], outputs returns FF
DIGIT_wd: ? # (ascii_char - digit_value )

    X X; TOS Z; Z X; Z Z; # X(+) holds char

    # switch (X) {
    i20  X ;              #
    iF   X DIGIT_cd_inval #  X<=2F
    iA   X DIGIT_cd_09    #  X<=39, '0'-'9'
    i7   X DIGIT_cd_inval #  X<=40
    i10  X ;              #    (50)
    iA   X DIGIT_cd_az    #  X<=5A  'A'-'Z'
    i6   X DIGIT_cd_inval #  X<=60
    i10  X ;              #    (70)
    iA   X DIGIT_cd_az    #  X<=7A  'a'-'z'
    Z    Z DIGIT_cd_inval #  X>7A

    0d 0d 0d #should jump upward


# helper:
DROP_TO_neg1_wd: do_colon #( -1 [+num +num +num ] -- )
    # Loop as long as TOS >= 0
    _0lt_wd  _0BRANCH_wd 0FFFE #jump -2
    EXIT_wd

# Tries to parse strp as a number in the current BASE
# If gets an out of range digit, fails
# Handles leading -
NUMBER_hd: DIGIT_hd 0 6 "NUMBER"
NUMBER_wd: do_colon #(strp -- number 1  OR  0 )
    STRCHARS_wd # (-1 [lastchar ... firstchar] )

    # ==== PREPARE SIGN BIT on RS (0pos, 1neg)
    LIT_wd 0 #start pos

    # (-1 [chars] sign )
    OVER_wd LIT_wd 2D _eq_wd # if starts with '-'
    _0BRANCH_wd 004 #skip 3 (+4)
        # IF '-': Drop hyphen, change sign bit to 1
        SWAP_wd DROP_wd _1plus_wd
        # ELSE
    #THEN: Push sign bit to RS
    _toR_wd

    LIT_wd 0 #Start with total = 0

    #BEGIN ( -1 [chars...] total )
        OVER_wd _0ge_wd _0BRANCH_wd 16 # 0>= is 0 iff -1, jump exit (+dec22 wds, 0x16)
        # WHILE

        SWAP_wd DIGIT_wd # Parse digit ( -1 [...chars-1] total digit )

        # If DIGIT >= BASE, error
        DUP_wd BASE_wd _at_wd _ge_wd
        _0BRANCH_wd 07 #skip over 6 wods (+7)
            # IF digit >= base (-1 [chars] total digit )
            _2DROP_wd
            _fromR_wd # pop sign from RS (0 or 1)
            DROP_TO_neg1_wd # Drop all remaining chars
            #return  0
            LIT_wd 0000 EXIT_wd
        #THEN

        # multiply digit into total
        SWAP_wd BASE_wd _at_wd _times_wd _plus_wd
        # (-1 [chars] total)

        BRANCH_wd 0FFE8 # jump back dec24 words (-0x18)
    # END, jump back up

    # (-1 total)
    # Apply sign bit (from RS)
    _fromR_wd _0BRANCH_wd 2
        # If sign
        NEG_wd
    #THEN

    # return (total 1)
    SWAP_wd _2plus_wd EXIT_wd

# ================================================================
#
#                       DICTIONARY WORDS
#
# ================================================================
# , STR,
# (vars:) WIP
# CREATE
# >CFA >DFA
# : ;
# ?IMMED
# TODO: IMMEDIATE?
# FIND

_comma_hd: NUMBER_hd 0 1 ","
_comma_wd: do_colon #( x - [encloses x in dict] )
    DP_wd _at_wd _bang_wd #put X at *DP
    LIT_wd 1 DP_wd _plusbang_wd #inc DP
    EXIT_wd

STR_comma_hd: _comma_hd 0 4 "STR,"
STR_comma_wd: do_colon #( strp - [copies x into dict, encloses] )
    DP_wd _at_wd TUCK_wd  # ( DP@ strp DP@ )
    STRCPY_wd #Copy into dict (DP@)
    _at_wd # (strlen)
    _1plus_wd DP_wd _plusbang_wd # inc DP by strlen+1
    EXIT_wd

WIP_hd: STR_comma_hd 0 3 "WIP"
WIP_wd: do_var 0

CREATE_hd: WIP_hd 0 6 "CREATE"
CREATE_wd: do_colon # ( strp - )
    # creates wordheader at DP, encloses it in dict
    # links to LATEST
    # sets WIP to point to curr header

    DP_wd _at_wd WIP_wd _bang_wd  #point WIP to DP

    # Create header:
    LATEST_wd _at_wd _comma_wd # link: latest
    LIT_wd 0 _comma_wd         # flags: 0
    STR_comma_wd               # enclose string header
    EXIT_wd

_toCFA_hd: CREATE_hd 0 4 ">CFA"
_toCFA_wd: do_colon #(word_header_address - CFA)
    _2plus_wd #skip link and flag
    DUP_wd _at_wd # get length
    _plus_wd _1plus_wd # Skip string
    EXIT_wd

_toDFA_hd: _toCFA_hd 0 4 ">DFA"
_toDFA_wd: do_colon #(word_header_address - DFA)
    _toCFA_wd _1plus_wd EXIT_wd

# TODO: this isn't correct, later gotta add proper flags
_qIMMED_hd: _toDFA_hd 0 6 "?IMMED"
_qIMMED_wd: do_colon #(word_header_address - 1/0 [if is immed])
    _1plus_wd _at_wd _0ne_wd EXIT_wd


_colon_hd: _qIMMED_hd 0 1 ":"
_colon_wd: do_colon
    DP_wd _at_wd WIP_wd _bang_wd # Point WIP to current word
    TOKEN_wd CREATE_wd    #read token + create header
    DO_COLON_wd _comma_wd #setup CFA with do_colon
    LIT_wd 1 STATE_wd _bang_wd #Enter compile mode
    EXIT_wd

_semicolon_hd: _colon_hd 1 1 ";" #IMMEDIATE
_semicolon_wd: do_colon
    LW_EXIT_wd _comma_wd #enclose EXIT_wd
    WIP_wd _at_wd LATEST_wd _bang_wd # Link WIP into latest
    LIT_wd 0 WIP_wd _bang_wd # Clear WIP
    LIT_wd 0 STATE_wd _bang_wd # exit compile mode
    EXIT_wd


FIND_hd: _semicolon_hd 0 4 "FIND"
FIND_wd: do_colon # (strp - [dict_header or 0])

    # Start searching at latest header
    LATEST_wd _at_wd
    SWAP_wd

    # loop (hdrp strp):
        OVER_wd _0BRANCH_wd  0E # if curr hdr is nullptr, jump to exit (+dec14)

        # ==== COMPARE TGT TO CURRENT HEADER get len, compare
        # (hdr str)

        #prepare 2 string pointers
        OVER_wd  # ( hdr str hdr )
        _2plus_wd OVER_wd #(hdr str hd_str str)

        # compare strings
        STR_eq_wd _0BRANCH_wd   3
            #If strings equal: (hdr str), return header
            DROP_wd EXIT_wd
        # Else, (hdr str), go to next entry
        SWAP_wd _at_wd SWAP_wd

        BRANCH_wd 0FFF1 #jmp loop (-dec15, -F)
    #end loop

    # (0 strp) reached nullptr, return 0
    DROP_wd EXIT_wd

# ================================================================
#
#                       EXECUTION WORDS
#
# ================================================================
# INTERPRET

# Temp bootstrap words:
_qEXECUTE_wd: do_colon # ( wha -- )
    # IF state 0 or wd is immediate, execute
    # else compile it

    DUP_wd _toCFA_wd SWAP_wd # (cfa wha -- )


    #CSPLIT_wd EMIT_wd EMIT_wd
    _qIMMED_wd _0BRANCH_wd 3 #(cfa)
        # If immediate:
        EXECUTE_wd EXIT_wd

    # (cfa)
    STATE_wd _at_wd _0BRANCH_wd 3
        # If state=1 (compile)
        _comma_wd EXIT_wd

    #else: state = 0
    EXECUTE_wd EXIT_wd


_qNUMBER_wd: do_colon # ( N -- [?])
    # Compiles if state 1, else leaves on stack
    STATE_wd _at_wd _0BRANCH_wd 4
        # If state=1
        LW_LIT_wd _comma_wd _comma_wd #compile "LIT N"

    # If compiled, stack is empty
    # If state=0, leave number on stack
    EXIT_wd


INTERPRET1_wd: do_colon
    TOKEN_wd

    DUP_wd FIND_wd # Try FIND (tok wha|0 -- )
    DUP_wd
    _0BRANCH_wd 005
        # If found word,
        SWAP_wd DROP_wd #drop token
        _qEXECUTE_wd EXIT_wd #exec/compile, exit

    DROP_wd # We have an extra 0 becasue we didn't ?DUP

    #ELSE:
    DUP_wd NUMBER_wd # Try NUMBER (tok (n 1 | 0) -- )
    _0BRANCH_wd 005
        # If found number
        SWAP_wd DROP_wd #drop token
        _qNUMBER_wd EXIT_wd

    #ELSE:
    # token is \n or invalid
    DUP_wd _1plus_wd _at_wd  # ( tok firstchar )
    LIT_wd 0A _eq_wd _0BRANCH_wd 003  # '\n' = IF
        # If was \n: continue
        DROP_wd EXIT_wd

    # ELSE: invalid token, print a warning, restart
    # ( tok )
    NL_wd TELL_wd
    LIT_wd 3F EMIT_wd  # '?'
    NL_wd

    # RESTART (the assmebler can't do forward labels, so init stashes the addr here)
    LIT_wd restart_wd_addr _at_wd EXECUTE_wd
    HALT1_wd #shouldn't reach here


INTERPRET_hd: FIND_hd 0 9 "INTERPRET"
INTERPRET_wd: do_colon
    INTERPRET1_wd
    BRANCH_wd 0FFFE # branch -2

# ================================================================
#
#                      TEST FUNCS AND MAIN
#
# ================================================================


# Should emit "Hello"
TEST_STACK1_wd: do_colon
    LIT_wd 65 # e
    LIT_wd 6C # l
    LIT_wd 6F # o
    LIT_wd 48 # H
    LIT_wd 69 # i
    LIT_wd 78 # x
    LIT_wd 78 # x
    DROP_wd _2DROP_wd # ( e l o H )
    _ROT_wd # ( e H l o)
    _2SWAP_wd # ( l o e H )
    EMIT_wd
    EMIT_wd # "He" ( l o )
    SWAP_wd DUP_wd  # ( o l l )
    EMIT_wd EMIT_wd EMIT_wd # "llo"
    EXIT_wd



TEST_STACK2_wd: do_colon # should print "badc acb bac"
    ## Test 2SWAP, 2DROP
    LIT_wd 61 LIT_wd 62 LIT_wd 63 LIT_wd 64 # ( a b c d )
    _2SWAP_wd # ( c d a b )
    EMIT_wd EMIT_wd EMIT_wd EMIT_wd # "badc"
    SPACE_wd

    # Test ROT
    LIT_wd 61 LIT_wd 62 LIT_wd 63 # ( a b c )
    ROT_wd  # ( b c a)
    EMIT_wd EMIT_wd EMIT_wd #should print "acb"
    SPACE_wd

    # Test _ROT
    LIT_wd 61 LIT_wd 62 LIT_wd 63 # ( a b c )
    _ROT_wd  # ( c a b)
    EMIT_wd EMIT_wd EMIT_wd #should print "bac"

    EXIT_wd

TEST_RETSTACK_wd: do_colon
    # Test return stack
    NL_wd
    LIT_wd 49 # I
    LIT_wd 4A # J
    LIT_wd 4B # K
    LIT_wd 21 # !
    _toR_wd # ! should be hidden on return stack
    _ROT_wd SWAP_wd # ( K J I )
    EMIT_wd EMIT_wd EMIT_wd #should print "IJK"
    _fromR_wd EMIT_wd # "!"

    #_fromR_wd EMIT_wd # reads canary, 0xCAFE (emits 0xfe)
    EXIT_wd

TEST_VARS_wd: do_colon # should emit: 0A 10 0A 0A 20
    BASE_wd _at_wd EMIT_wd #Base starts at 0A
    LIT_wd 10 BASE_wd _bang_wd BASE_wd _at_wd EMIT_wd # Set to 0x10, fetch, emit

    LIT_wd 1 BASE_wd _plusbang_wd  #Add 1
    LIT_wd 7 BASE_wd _minusbang_wd #subtract 7
    BASE_wd _at_wd EMIT_wd #should emit 0A

    BASE_wd _at_wd EMIT_wd #should emit 0A

    DO_COLON_wd EMIT_wd #should emit 20 (since DO_COLON is at 0820?)

    EXIT_wd

TEST_MATH_wd: do_colon #Should emit 23 00 03 04 46 fa   20
                       #     then:  01 05 01 05 01 05 00 02 20 2A
    LIT_wd 5 LIT_wd 7 _times_wd EMIT_wd # 5*7=35 (0x23)
    LIT_wd 0 LIT_wd 3 _times_wd EMIT_wd # 0*3=0
    LIT_wd 3 LIT_wd 1 _times_wd EMIT_wd # 3*1=3
    LIT_wd 0FFFE LIT_wd 0FFFE _times_wd EMIT_wd #-2*-2, should be +4
    LIT_wd 0FFF6 LIT_wd 0FFF9 _times_wd EMIT_wd #-A*-7, should be +70 (0x46)
    LIT_wd 0FFFE LIT_wd 3 _times_wd EMIT_wd #-2*3, should be -6 (0xFFFA, emits fa)

    SPACE_wd

    LIT_wd 10 LIT_wd 3 _divmod_wd EMIT_wd EMIT_wd #dec16 3 /MOD
    LIT_wd 0FFF0 LIT_wd 0FFFD _divmod_wd EMIT_wd EMIT_wd #-dec16 -3 /MOD

    LIT_wd 0FFF0 LIT_wd 3 _divmod_wd #-dec16 3 /MOD , should be (-5div -1rem)
    NEG_wd EMIT_wd NEG_wd EMIT_wd #should emit 01 05
    LIT_wd 0A LIT_wd 5 _divmod_wd EMIT_wd EMIT_wd #0A 5 /MOD (exp: emit rem0 quot2)

    SPACE_wd
    LIT_wd 30 LIT_wd 2 _minus_wd LIT_wd 8 _minus_wd #dec 48 -2 -8 = dec38
    _1plus_wd _1plus_wd LIT_wd 2 _plus_wd # dec38 +1 +1 +2 = decimal42 = 0x2A '*'
    EMIT_wd

    EXIT_wd

TRUE_FALSE_wd: do_colon # (bool - 'T' or 'F')
    # If true, pushes T, else F
    LIT_wd 46 #'F'
    SWAP_wd _0BRANCH_wd 4 #if 0, stay on F
    DROP_wd LIT_wd 54 #'T' #else: T
    EXIT_wd
    0d 0d 0d

TEST_BRANCH_wd: do_colon # Prints "*****" using a loop
    #Comparisons should print a solid block of "T"

    LIT_wd 5
    # loop: (-8)
    _1minus_wd DUP_wd
    LIT_wd   2A   EMIT_wd
    _0BRANCH_wd 3 #if 0, jump ahead to exit
    BRANCH_wd 0FFF8

    NL_wd

    # Test comparisons
    LIT_wd 1 LIT_wd 1 #Should be TFFFTT
    _2DUP_wd _eq_wd         TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _ne_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _gt_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _lt_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _ge_wd         TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _le_wd         TRUE_FALSE_wd EMIT_wd
    _2DROP_wd NL_wd

    LIT_wd 2 LIT_wd 1 #Should be FTTFTF
    _2DUP_wd _eq_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _ne_wd         TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _gt_wd         TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _lt_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _ge_wd         TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _le_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    _2DROP_wd NL_wd

    LIT_wd 1 LIT_wd 2 #Should be FTFTFT
    _2DUP_wd _eq_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _ne_wd         TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _gt_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _lt_wd         TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _ge_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _le_wd         TRUE_FALSE_wd EMIT_wd
    _2DROP_wd NL_wd

    LIT_wd 1 #Should be FTTFTF
    DUP_wd _0eq_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    DUP_wd _0ne_wd         TRUE_FALSE_wd EMIT_wd
    DUP_wd _0gt_wd         TRUE_FALSE_wd EMIT_wd
    DUP_wd _0lt_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    DUP_wd _0ge_wd         TRUE_FALSE_wd EMIT_wd
    DUP_wd _0le_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    DROP_wd NL_wd

    LIT_wd 0 #Should be TFFFTT
    DUP_wd _0eq_wd         TRUE_FALSE_wd EMIT_wd
    DUP_wd _0ne_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    DUP_wd _0gt_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    DUP_wd _0lt_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    DUP_wd _0ge_wd         TRUE_FALSE_wd EMIT_wd
    DUP_wd _0le_wd         TRUE_FALSE_wd EMIT_wd
    DROP_wd NL_wd

    LIT_wd 0FFFF #Should be FTFTFT
    DUP_wd _0eq_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    DUP_wd _0ne_wd         TRUE_FALSE_wd EMIT_wd
    DUP_wd _0gt_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    DUP_wd _0lt_wd         TRUE_FALSE_wd EMIT_wd
    DUP_wd _0ge_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    DUP_wd _0le_wd         TRUE_FALSE_wd EMIT_wd
    DROP_wd NL_wd

    EXIT_wd

TEST_TOKEN_wd: do_colon # Should consume several tokens
    # When reading in "1 2\n3\n 4\n"
    # Should output: "T1 T2 T\n T3 T4 T\n "
    # (i.e. shouldn't drop newlines)

    # Print T, then the token, then a space
    TOKEN_wd LIT_wd 54 EMIT_wd TELL_wd SPACE_wd
    TOKEN_wd LIT_wd 54 EMIT_wd TELL_wd SPACE_wd
    TOKEN_wd LIT_wd 54 EMIT_wd TELL_wd SPACE_wd
    TOKEN_wd LIT_wd 54 EMIT_wd TELL_wd SPACE_wd
    TOKEN_wd LIT_wd 54 EMIT_wd TELL_wd SPACE_wd
    TOKEN_wd LIT_wd 54 EMIT_wd TELL_wd SPACE_wd
    EXIT_wd

TEST_FIND_wd: do_colon #Takes input on STDIN: if valid word, should emit XT. Else emit 0
    # Emit ptr to LATEST
    LATEST_wd _at_wd CSPLIT_wd EMIT_wd EMIT_wd

    TOKEN_wd

    # TRY str= with token?
    #DUP_wd LATEST_wd _at_wd _2plus_wd STR_eq_wd EMIT_wd

    # Try to find token
    FIND_wd CSPLIT_wd EMIT_wd EMIT_wd

    # Try to find R>
    LITSTR_wd 0B "Finding R>" 0A TELL_wd
    LITSTR_wd 2 "R>" FIND_wd
    CSPLIT_wd EMIT_wd EMIT_wd

    EXIT_wd

TEST_NUMBER_wd: do_colon #Takes input on STDIN. Parses as number, emits
    TOKEN_wd

    #STRCHARS_wd DROP_TO_neg1_wd EMIT_wd EMIT_wd EMIT_wd EMIT_wd

    #LIT_wd 43 DIGIT_wd EMIT_wd #Parse 'C'

    NUMBER_wd
    EMIT_wd EMIT_wd

    EXIT_wd

TEST_STRCPY_wd: do_colon #Should emit "Hello"
    LITSTR_wd 5 "Hello"
    #DUP_wd EMIT_wd _at_wd EMIT_wd #debug: show ptr, show len

    DP_wd _at_wd
    STRCPY_wd #copy token to DP

    #DP_wd _at_wd _at_wd EMIT_wd

    #DP_wd _at_wd _at_wd EMIT_wd #DEBUG show len (DP@@)
    #DP_wd _at_wd _1plus_wd _at_wd EMIT_wd #DEBUG show len (DP@@)
    DP_wd _at_wd TELL_wd

    EXIT_wd

TEST_CREATE_wd: do_colon #Should emit 00 00 00 30 (first not found, then found)
    #Creates a new word at WIP called "HELLO"
    LITSTR_wd 5 "HELLO"
    CREATE_wd

    # Search for it
    LITSTR_wd 5 "HELLO"
    FIND_wd
    CSPLIT_wd EMIT_wd EMIT_wd

    # enclose HELLO at latest
    WIP_wd _at_wd LATEST_wd _bang_wd


    #LITSTR_wd 2 "R>"
    LITSTR_wd 5 "HELLO"
    FIND_wd
    CSPLIT_wd EMIT_wd EMIT_wd

    EXIT_wd

TEST_EXECUTE_wd: do_colon # Should emit "A"
    LIT_wd 41

    LITSTR_wd 4 "EMIT"
    FIND_wd _toCFA_wd
    #CSPLIT_wd EMIT_wd EMIT_wd #DEBUG: show found CFA
    EXECUTE_wd

    EXIT_wd

# Should emit "H ii"
TEST_wd: do_colon
TEST_bd:
    #TEST_STACK1_wd SPACE_wd
    #TEST_STACK2_wd SPACE_wd
    #TEST_RETSTACK_wd SPACE_wd
    #TEST_VARS_wd
    #TEST_MATH_wd

    #NOSP__wd EMIT_wd
    #RSP__wd EMIT_wd

    #TEST_BRANCH_wd

    TEST_TOKEN_wd
    #TEST_FIND_wd

    #TEST_NUMBER_wd
    #TEST_STRCPY_wd
    #TEST_CREATE_wd

    #TEST_EXECUTE_wd

    #INTERPRET_wd


    HALT1_wd


# Should never return
MAIN_wd: do_colon
    #TEST_wd
    INTERPRET_wd
    EXIT_wd



# ========= STARTUP FLOW
# Restart: Resets transient state to known-good values for outer interp
#          ( BASE, WIP, STATE, etc )
#          Clears RSP (RESTART is outermost func)
#          Calls MAIN
#          if return from main, halt

# If main returns, it will return here, so we can error out
RESTART_hd: INTERPRET_hd 0 7 "RESTART"
RESTART_wd: do_colon
RESTART_bd:
    LIT_wd 0A BASE_wd _bang_wd # BASE 10

    # Init return stack
    RS0_wd _1plus_wd NEG_wd RSP__wd _bang_wd # RSP(-) = RS0+1, points to canary


    LITSTR_wd 08 "STARTING" TELL_wd NL_wd

    #TODO: fix canaries

    MAIN_wd # JUMP TO MAIN

    # SHOULDN'T EXIT
    LITSTR_wd 0B "MAIN EXITED" TELL_wd NL_wd
    HALT1_wd

# ======= INITIAL CONSTS for startup stuff
forth_canary_val: 0CAFE
#forth_stack_base_val: dstack_base #(+)
forth_rstack_base_val: rstack_base
forth_init_dp_val: 3000
forth_init_restart_wd: RESTART_wd # first forth word we jump to after START


# Start: inits persistent state constants
#   Sets up for execution of primaries (SP, TOS, canaries)
#
#   Copies in initial constants that we weren't able to due to assembler
#        Setups up NWA to point to RESTART, jumps to NEXT
#        ( LATEST, DP, etc, NOSP_, etc )
#
forth_init_latest_val: ? # Constant that points to START_hd
START_hd: RESTART_hd 0 5 "START"
START_wd: ?
START_cd: # Starts executing here with no state

    #=== INIT STACK
    # (Stack base is at DS0. First item on stack will be at DS0
    #  With empty stack, SP should point to DS0+1
    #  Because we're using NOSP (TOS in a reg), NOSP points to DS0+1)
    #NOSP_ NOSP_; forth_stack_base_val NOSP_; # NOSP(-) = DS0
    NOSP_ NOSP_; DS0_val NOSP_; # NOSP(-) = DS0
    i2 NOSP_ ; #NOSP(-) -= 2 ; NOSP(-) = DS0+2

    # Init stack canary at TOS (will be written to DS0+1)
    TOS TOS; forth_canary_val Z; Z TOS; Z Z; #push CAFE to TOS as a marker?

    # ==== Init consts
    # (we'd assemble these directly but we don't
    #  have forward labels in asm2)
    DP_val          DP_val         ; forth_init_dp_val     Z; Z DP_val;     Z Z;
    LATEST_val      LATEST_val     ; forth_init_latest_val Z; Z LATEST_val; Z Z;
    restart_wd_addr restart_wd_addr; forth_init_restart_wd Z; Z restart_wd_addr; Z Z;


    # ==== START EXECUTING RESTART
    # ( it will initialize return stack and other vars)

    # set up NWA to point to first word of RESTART
    #   ( we don't want to enter RESTART as a subword, just start executing )
    NWA NWA; forth_init_restart_wd Z; Z NWA; # NWA = RESTART >CFA
    n1 NWA; # NWA = RESTART >DFA
    Z Z NEXT_cd # Start executing restart


# =============================== MAIN LOOP

#Note: expects first char of input in C (-)
# clobbers X, jumps to one of the parser funcs
# parser funcs jump back here (directly, not using return mechanism)

@2000 # main
Z Z 2100
Z Z halt0



@2100 # forth_init
    # SUBLEQ ASM STUFF

    # write 0d to entry so that we halt if we start executing at 0
    entry entry; nD entry;

    Z Z START_cd # Jump to START



@2200 # custom_test:
# alternate entry for calling into test funcs?
    Z Z halt0  # exit


#...
#@3000 is dict, grows upward


# ========== GADGETS / CODE SNIPPETS


#Snippets:
#
# JLEZ(X,LOC): Z X LOC
# JGEZ(X,LOC): T T; X T LOC
# JGTZ(X,LOC): T T; $-1 T; X T LOC;
# JLTZ(X,LOC): T T; X T ?+3; Z Z LOC;
#
# SUBJGE(X,Y,LOC): X Y LOC;            #Y -= X
# SUBJLE(X,Y,LOC): T T; X Y; Y T LOC;  #Y -= X
#
#
# JGE(X,Y,LOC): T T; Y Z; Z T; Z Z; X T LOC;
# JLE: mirror
#
# GADGET: jsr  (1-level)
#   R  R  ?
# ?+5  R  ?            # copy constant retaddr to R(-)
#   Z  Z  sub_routine  # jump subroutine
#   ?                  # constant ret_addr
#   _  _  _            # returns to here
#
# (JSR oneliner)
# R R; ?+5 R; Z Z subroutine   ? #JSR
#
# GADGET: retsub  (1-level)
# ?+7 ?+6    ?
#   R ?+3    ?    #set Q = -R
#   Z   Z  Q:0    #jmp -R
#


# GADGET: FETCH_SUBTRACT: *(-P) X
# ?+5 ?+4; #   : Q   Q     #
#   P ?+1; #   : P   Q     #
#   _   X; #   : Q:_ X     # X -= *(-P)

# GFETCH_SUB:   ptr(-)       tgt
# ?+5 ?+4;        P   ?+1; 0  X;  # X -= *(-P)
#
# GFETCH:           ptr(-)         tgt
# X X; ?+5 ?+4;        P   ?+1; 0  X;  # X = -*(-P)
#
# X X; ?+5 ?+4; P1 ?+1; 0 X; # GADGET:FETCH X = -*(-P1)
# ?+5 ?+4; P1 ?+1; 0 X; # GADGET:FETCH X -= *(-P1)
#
# ?+6  ?+5 ; P1 ?+2 ; X 0; # GADGET: POKESUB(P1), *(-P1) -= X
#
# # GADGET: POKE: *(P-) = -X
# ?+11 ?+10; P_ ?+D;  # set J
# ?+C  ?+B ; P_ ?+8;  # set K
# ?+9  ?+8 ; P_ ?+5;  # set L
# 0    0   ; X_   0;  # J K; (_) L

# # GADGET: POKE:
# ?+11 ?+10; P_ ?+D; # *(P-) = -X
# ?+C  ?+B ; P_ ?+8; # .
# ?+9  ?+8 ; P_ ?+5; # .
# 0    0   ; X_   0; # .
#
## ===== Stack Gadgets
# ### Push TOS into NOS
# T T; TOS T;
# n1 NOSP_; #grow stack
# ?+11 ?+10; NOSP_ ?+D; # GADGET: NEG!NOS(T)
# ?+C  ?+B ; NOSP_ ?+8; # .
# ?+9  ?+8 ; NOSP_ ?+5; # .
# 0    0   ; T   0; # .
#
# ### Pop NOS into Z
# ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: @NEGNOS(Z)
# i1 NOSP_; #shrink stack
