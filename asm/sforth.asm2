# First attempt at writing a threaded-interpreter
# (i.e. forth-style inner loop, can simply list addresses of subroutines and it will nest them properly)
#
# ==== MAIN FORTH TODO ======:
#
# Low priority:
# - FLAGS? [F_IMMED], bitwise ops [needed for 2nd outer interp, but doing it lazily for now]
# - shifts, bitwise ops
# - STRCHARS can just be a CMOVE into stack space, with special case for TOS
#
# LONG-TERM-PROJECT: NEG-OPTIMIZATION?
# - word-addresses negative? (fetch CWA goes from 3 to 1)
# - codeword address negative? (jmp(*CWA) goes from 4 to 2)
# - codewords 0 0 CW? (jmp(*CWA) goes from 4 to 1)
# - variables/constants negative?
#
# PUSH-POP OPTIMIZATION? (not worth it)
# - psh/pop gadgets as subroutines?
#   - all SP inc/dec would need to be set in 4 places
#   - would need to handle returns
#   - COSTS:
#       push is 2 ops + return
#       pop is  1 op + return (clear X as you call)
#   - Calling cost: 3 ops

# ===== NOTES ON MEMORY LAYOUT, CALLING CONVENTIONS, ETC
# = Notes on signedness:
# In memory strings are (+)
# In vars, chars are usually (-)
# In memory values are usually (-) (so + when read)
# Pointers in vars are usually (-) (so + when peeked/poked)
# Pointers in globals are usually (+) (so - when they go into vars?)
#
# = Notes on register conventions:
# ??
#
# = Notes on call/return conventions:
# ??
#
# = Notes on exiting / error catching:
# - uninitialized memory is at 0d
# - If we jump to 0d, we should halt (need 0f to point back to 0d)
# - If we forth jump to 0d, we should read
#
# ===== Forth Notes:
# XXXX_hdr is a dictionary header
# XXXX_wd is the code-field-address, ie. an execution token
# XXXX_cd is assembly code that can be jumped to
# XXXX_bd is body of secondary word

# Dictionary header is LINK, FLAGS, STRLEN, [STR...], CF, BODY
# =========  HEADER

@0 # Z T entry       P1  M1  0 0
Z:0 T:0 entry: 2000

@8 # IO ports
IN: 0
OUT: 0
alu_A: 0
alu_B: 0

# == Uninitialized mem catcher
#   If ASM jumps to uninitialized memory,
#     - we'll execute `0d 0d 0d`, jump to 0d, execute `Z Z catch_bad_mem`
#     - so we get to catch_bad_mem with *(0d) == 0

#   If we `garbage EXECUTE` ( i.e. execute a bad xt, forth-branch to data)
#   - NWA points to garbage
#   - CWA = *(NWA) = garbage
#   - CW = *(garbage) = 0d (jumps to 0d)
#   - asm executes `150 0 catch_bad_mem`  ( NOTE: *(150) should be 0 so we still jump )
#   - so we get to catch_bad_mem with *(0d) == 150
#
#   if we `garbage NWA !` (e.g. bad returnaddr, run off end of word, forth-branch to blank mem)
#       - NWA points to blank mem (0d)
#       - CWA = *(NWA) = 0d
#       - CW = *(0d) = 150  (catch_bad_codeword)
#       - so we jump to catch_bad_codeword
@0d   0150 00 0140

@10 #ALU outputs
# & | ^ _   << >> _ _
alu_and: 0
alu_or: 0
alu_xor: 0
0
alu_ls: 0
alu_rs: 0
alu_ars: 0

# ========  REGISTERS AND CO.

@20 #Unsaved registers, used for primitive routines
X:0 Y:0 V:0 W:0
P1:0 P2:0 Q1:0 Q2:0

#Saved registers (only modify these if you're top-level, or save them first)
#(TODO)
@28 #
      0  0  0  0     0  0  0   @2F R: 0

@30 #Global vars (_ indicates it's negated)
C_:0  C_needs_fetch:1

#C is last char read (-)   (treated as first char of input)
#C_needs_fetch will be 0 if C_ holds a valid char
#    That way if C already holds a previous char, we
#    can skip fetching a fresh one like so:
#      Z C_needs_fetch ?+6
#          C_ C_; IN C_;  # needs_fetch=1, fetch a fresh char
#      # else, needs_fetch==0, we already had one



# ======== Small integer constants:

@40
#4_: Positive ints: 0-F
i0: 0  i1: 1  i2:  2 i3:  3 i4:  4 i5:  5 i6: 6  i7:  7
i8: 8  i9: 9  iA: 0A iB: 0B iC: 0C iD: 0D iE: 0E iF: 0F

@50
#5_: Negative ints: -0 - -F
    00000 n1: 0FFFF n2: 0FFFE n3: 0FFFD n4: 0FFFC n5: 0FFFB n6: 0FFFA n7: 0FFF9
n8: 0FFF8 n9: 0FFF7 nA: 0FFF6 nB: 0FFF5 nC: 0FFF4 nD: 0FFF3 nE: 0FFF2 nF: 0FFF1

@80
#8_: 00-F0 (tens)
      0  i10: 10  i20: 20  i30: 30  i40: 40  i50: 50  i60: 60  i70: 70
i80: 80  i90: 90  iA0: 0A0 iB0: 0B0 iC0: 0C0 iD0: 0D0 iE0: 0E0 iF0: 0F0

@90
#9_: (-00) - (-F0)
     00000 n10: 0FFF0 n20: 0FFE0 n30: 0FFD0 n40: 0FFC0 n50: 0FFB0 n60: 0FFA0 n70: 0FF90
n80: 0FF80 n90: 0FF70 nA0: 0FF60 nB0: 0FF50 nC0: 0FF40 nD0: 0FF30 nE0: 0FF20 nF0: 0FF10



# ======== Misc jump spots

@0D0 #error_page
halt0:   0  0 0D0    #D0:   halt0 #success
halt1:   1  1 0D3    #D3:   err: halt1 #
halt2:   2  2 0D6    #D6:   err: halt2 # Tried to forth-execute word 0d
halt3:   3  3 0D9    #D9:   err: halt3 # Jumped to 0d (probably forth-executed word pointing to invalid memory)
halt4:   4  4 0DC    #DC:   err: halt4 # Executed 0d 0d 0d


@0F0 retsub:
 ?+7 ?+6    ?    #
   R ?+3    ?    #set Q = -R
   Z   Z  0FF    #jmp -R  (FF temp, gets Q)



# === ASM EXCEPTIONS ===
# saves state to stack (CWA NWA RSP exception code )
# Initializes reserve return stack
# Jumps to handle_exception
@100  #NOTE: must Z Z before jumping here
    except6: i1 Z; # 6: not implemented error
    except5: i1 Z; # 5: divide by zero
    except4: i1 Z; # 4: bad asm ( executed 0d 0d 0d)
    except3: i1 Z; # 3: bad asmjump ( jumped to 0d ) CW=0d
    except2: i1 Z; # 2: bad forthbranch CWA=0d
    except1: i1 Z; # unused?
    except0:       # unused? success?

    # NOW:
    X X; Z X; # save X(+) = exception_code
    Z Z 8A0 # Jump to handle_exception_X


# ===== BAD MEMORY CATCHER (see notes near @0D )
@140  catch_bad_mem: # jumping to 0d ends up here
    # if we jumped to uninitialized memory, we'd first execute 0d 0d 0d, so 0d will be 0
    Z Z ; Z 0d except4 # if 0d == 0, halt4 (ASM executed 0d 0d 0d)

    # else, 0d still contains 150, so we must have jumped directly to 0d
    Z Z except3 # halt3 # (ASM jumped directly to 0d)

# executed CWA = 0d
@150 catch_bad_codeword: # executing a CF of 0d will load this as the interpreter
    # Note: address 150 must be 0 so that jumping to 0D yields LEQZ and jumps
    Z Z except2

@160
halt5: 5 5 halt5 #halt5: divide by zero
halt6: 6 6 halt6 #halt6: not implemented / assert error
halt7: 7 7 halt7 #halt7: Exception in Exception
#halt7: 7 7 halt7 #halt7:
#halt7: 7 7 halt7 #halt7:
#halt7: 7 7 halt7 #halt7:
haltE: 0E 0E haltE #haltE: EOF


# ====================== CORE FORTH VARS
@200
# NWA/CWA: in-code pointers (see NEXT_cd:)

# VARS:

# Stacks: We want to keep the top of stack in a var for easier access
TOS: 0 #Will be initialized to 0CAFE canary value
NOSP_: 0 #NOSP(-) points to NOS, i.e. 1 below TOS
# NOTE: initialized to point 2 higher than stack_base: i.e. at stack canary
#       initial (invalid) value of TOS will be pushed to canary (base+1), then first real val will be at stack_base

#TORS: 0
RSP_: 0 #RSP(-) points to next free space

#Data stack (grows downward)
@210 dstack_limit: 0CAFE
@300 dstack_base: 0d #TOS will go here
    0CAFE #canary
    0CAFE #canary2 (we'll pop this into TOS if we . with an empty stack)

@310 rstack_limit: 0CAFE
@400 rstack_base: 0d #Return stack (grows downward)
    0CAFE #canary

# Token buffer (NOTE: first location is length)
@440 token_buff:
@480 #end of token buffer
#


@550 # strcmp:
strcmp:
# We have two strings, the lengths matched
# (strings with lengths at strp[0])
# ARGS:
#   P1(-), P2(-) point to their start (length byte)
# RETURNS:
#   X(+): 1 if ==, else 0
# CLOBBERS:
#   X Y V W
#
# Y- will hold strlen 1
# V- will hold strlen 2
#
# X will hold loop counter (-len)
# W: tmp, test char
# cP1 will hold ptr to curr char of iter str
# cP2 will hold ptr to curr char of new-interning str

    #Fetch lengths into Y and V
    Y Y; ?+5 ?+4; P1 ?+1; 0 Y; # GADGET:FETCH Y = -*(-P1)
    V V; ?+5 ?+4; P2 ?+1; 0 V; # GADGET:FETCH V = -*(-P1)

    # Check if lengths match (Y-V=0)
    Y V ?+3  # if V-Y <= 0, jump nextif
    Z Z 5E0  # else V-Y >0, jump strcmp_neq
    V Z ?+3  # nextif V-Y >= 0 (V-Y==0): strcmp worked
    Z Z 5E0  # else V-Y < 0, jump strcmp_neq

    # If we get here, lengths matched, do strcmp
    Z Z; X X;
    Y Z; Z X; Z Z; # X- = len Y(-)
    n1 X;     # X++ ( len-- )

    # Write ptrs into fetchloop code
    5AC 5AC; P1 5AC;  # cmpP1+ = (P1)  (loop skips len field)
    5AF 5AF; P2 5AF;  # cmpP2+ = (P2)  (loop skips len field)
    Z Z 5A0 #jmp to strcmp loop

@5A0 #strcmp_loop:
    # advance ptrs (+ so inc)
    n1 5AC; # CP1(+) ++
    n1 5AF; # CP2(+) ++

##   #fetch next char of each string into W, T
    T T; W W;
@5AC   0  W;  #   : cP1:_ W        #
@5AF   0  T;  #   : cP2:_ T        #

    T   W  ?+3 #   : T W ?+3        # W = *cP2 - *cP1
    Z   Z  ?+3 #   : jmp ?+3        #
    W   Z  5C0 #   : W Z strcmp_continue  # if  W == 0, chars matched, cmp next char
    Z   Z  5E0 #   : Z Z strcmp_neq  # else, string mismatch, try next str


@5C0 #strcmp_continue: #chars matched, keep checking rest of str
   Z Z; #fix Z
   n1 X 5A0 #   : $-1 X loop     # X++, if X<=0, jump strcmp_loop

# stcmp_end_of_loop:
# if we're here, we've successfully matched all the chars
   X X; n1 X; Z Z retsub #return 1

@5E0 #strcmp_neq, return 0
    X X; Z Z retsub



# ================= memcpy
@600 memcpy:
# P1(-) points to src
# P2(-) point to dest
# X(-) holds len to copy
#
# X will hold loop counter (-len)
# W holds fetched char
#
# cSP will hold src ptr
# cD1-3 will hold dest ptr

    # Write ptrs into fetchloop code
    623 623; P1 623;  # cmpSP+ = (P1)
    626 626; P2 626;  # cmpD1+ = (P2)
    627 627; P2 627;  # cmpD2+ = (P2)
    62A 62A; P2 62A;  # cmpD3+ = (P2)
    Z Z 638 #jmp to memcpy check, check first char

@620 memcpy_loop:
       W  W; #Fetch into W
@623   0  W;  #   : cSP:_     W     #
    # Put W into dest
@626   0  0;  #   : cD1:_  cD2:_    #
@629   W  0;  #   :     W  cD3:_    #

    # advance ptrs (+ so inc)
@62C n1 623; # CS1(+) ++
@62F n1 626; # CD1(+) ++
@632 n1 627; # CD2(+) ++
@635 n1 62A; # CD3(+) ++

# memcpy_check
@638  n1 X memcpy_loop #   : $-1 X loop     # X++, if X<=0, jump strcmp_loop

# stcmp_end_of_loop:
# if we're here, we've successfully copied all the chars
    Z Z retsub


# ================================================================
#
#                     CORE FORTH PRIMTIIVES
#
# ================================================================

@800
NEXT_cd: #Sets CWA=*NWA, NWA++, goes to EXECUTE_cd
@800   NWA: 0 Z ;       # fetch from NWA into Z(-)
@803   810 810; Z 810; # flip Z into CWA(+), @810
@809   n1 NWA ; # NWA++
       Z Z 810  # continue (skip some bytes for easier alignment of @s)

@810
RUN_cd: # Runs word at CWA, will continue at NWA

   CWA:0     Z; # fetch CW into jumpPTR (@81B)
@813   81B 81B;
@816   Z   81B;

# Jump to codeword
@819 Z Z  @81B 0  #jumpPTR @ 81B

# == TEMP DEBUG:
#@819 i1 i2 @81B 0  #jumpPTR @ 81B
#Z Z halt3


@820 do_colon: # Interpreter for forth-words
    # Pushes NWA to return stack
    # Sets NWA = CWA+1
    # jumps NEXT

    # == Push NWA to return stack
    n1 RSP_ ; #grow return stack
    T T; NWA T;
    # GADGET: POKE to RSP
    ?+11 ?+10; RSP_ ?+D; # *(RSP) = -X
    ?+C  ?+B ; RSP_ ?+8; # .
    ?+9  ?+8 ; RSP_ ?+5; # .
    0    0   ; T   0; # .

    NWA NWA;
    CWA Z; Z NWA; n1 NWA; #NWA = CWA+1
    Z Z NEXT_cd;


@879 #calculate this so that exit_wd ends up at 880, for debugging
EXIT_hd: 0 0 4 "EXIT"
@880 EXIT_wd: ?  # Exits a forth-word
    EXIT_cd:
    # Pops NWA from return stack
    Z Z; ?+5 ?+4; RSP_ ?+1; 0 Z; # GADGET:FETCH_NEG
    i1 RSP_; #shrink return stack

    NWA NWA; Z NWA;

    Z Z NEXT_cd; #Jump next


# ====== EXCEPTION RECOVERY

# When an exception occurs, we'll jump here with
# X(+) set to the exception code
# This will:
#   - push state onto the stack ( rsp nwa cwa except_code)
#   - changes RSP to point to a recovery area
#   - RUN HANDLE_EXCEPTION
@8A0 handle_exception_X:
    Z Z ?+2 # Skip over constants:

# XT of forth exception handler
# Gets called with ( rsp nwa cwa except_code -- )
# Note: rsp will be in a special recovery area, so don't
e_handler_val: 0DEAD # (constant, skipped over )

e_in_e: 0 # set to 1 if we're in an exception,

# Note: check for recursive exceptions
    Z e_in_e ?+3 # if <=0, we're ok
    Z Z halt7    # else >0, we've got an exception in an exception
    e_in_e e_in_e; n1 e_in_e;    # set e_in_e to 1

    ### Push TOS into 5OS
    T T; TOS T; n1 NOSP_; #grow stack
    ?+11 ?+10; NOSP_ ?+D; ?+C  ?+B ; NOSP_ ?+8; ?+9  ?+8 ; NOSP_ ?+5;
    0    0   ; T   0; # GADGET: NEG!NOS(T)

    ### Push RSP(+) into 4OS
        n1 NOSP_; #grow stack
        ?+11 ?+10; NOSP_ ?+D; ?+C  ?+B ; NOSP_ ?+8; ?+9  ?+8 ; NOSP_ ?+5;
        0    0   ; RSP_  0; # GADGET: NEG!NOS(T)
    ### Push NWA(+) into 3OS
        T T; NWA T ; n1 NOSP_; #grow stack
        ?+11 ?+10; NOSP_ ?+D; ?+C  ?+B ; NOSP_ ?+8; ?+9  ?+8 ; NOSP_ ?+5;
        0    0   ; NWA  0; # GADGET: NEG!NOS(T)
    ### Push CWA(+) into NOS
        T T; CWA T; n1 NOSP_; #grow stack
        ?+11 ?+10; NOSP_ ?+D; ?+C  ?+B ; NOSP_ ?+8; ?+9  ?+8 ; NOSP_ ?+5;
        0    0   ; T  0; # GADGET: NEG!NOS(T)

    # Put exception code in TOS
    Z Z; X Z; TOS TOS; Z TOS; # TOS(+) = X(-)

    # TODO: setup recovery return stack

    # copy e_handler into CWA, jump RUN
    Z Z ;
    CWA CWA; e_handler_val Z; Z CWA;
    Z Z RUN_cd




# ====== FORTH PRIMITIVE WORDS

@960 #WORDS

EXECUTE_hd: EXIT_hd 0 7 "EXECUTE"
EXECUTE_wd: ? # ( xt -- ; executes word on TOS, then continues)
    # NWA stays where it was, we'll return to
    # wherever EXECUTE was called from

    # set CWA to TOS (the word to execute)
    CWA CWA; TOS Z; Z CWA; Z Z; #CWA+ = TOS+

    # == Drop execution token (Pop NOS into TOS)
    TOS TOS;
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack
    Z TOS;

    # Jump to RUN_cd
    # this is jumping into NEXT_cd, but after we would have loaded
    # CWA=*NWA and incremented NWA
    # This will execute CWA (xt) and return to NWA
    Z Z RUN_cd

# Lost word, pointer will be in constant
TAILCALL_wd: ? #
    # Executes next word in compiled order (NWA)
    # Will return to caller's caller

    # We want the CWA that is at *NWA
    # However we can't just jump to next
    # since we need to point NWA back into caller's caller
    # So, manually fetch NWA
    P1 P1; NWA P1; # NWA into P1(-)
    ?+5 ?+4; P1 ?+1; 0 Z; # Fetch from P1(-) into Z(-)
    CWA CWA; Z CWA; # CWA+ = *NWA+

    # since we're a primary, caller is at NWA
    # caller's caller is on RS

    # Pops NWA from return stack
    Z Z; ?+5 ?+4; RSP_ ?+1; 0 Z; # GADGET:FETCH_NEG
    i1 RSP_; #shrink return stack

    # Write into NWA properly
    NWA NWA; Z NWA;

    Z Z RUN_cd

# ================================================================
#
#                  STACK MANIPULATION WORDS
#
# ================================================================
# >R R> R@ RPICK
# NOSP@ NOSP!
# DUP DROP 2DROP SWAP OVER 2SWAP ROT -ROT


_toR_hd: EXECUTE_hd 0 2 ">R"
_toR_wd: ? #(pushes from data stack to return stack)
_toR_cd:
    n1 RSP_ ; #grow return stack

    T T; TOS T;
    # GADGET: POKE +TOS to RSP
    ?+11 ?+10; RSP_ ?+D; # *(RSP) = -X
    ?+C  ?+B ; RSP_ ?+8; # .
    ?+9  ?+8 ; RSP_ ?+5; # .
    0    0   ; T   0; # .


    # Drop TOS (NOS->TOS)
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: -@NOSP(Z-)
    TOS TOS; Z TOS; # copy NOS into TOS(+)
    i1 NOSP_; #shrink stack (SP_ goes more negative)

    Z Z NEXT_cd

_fromR_hd: _toR_hd 0 2 "R>"
_fromR_wd: ? # pops from return stack to data stack
_fromR_cd:
    # GADGET: PUSH TOS
    TOS Z ;
    n1 NOSP_; #grow stack (NOSP_ goes closer to 0)
    ?+11 ?+10; NOSP_ ?+D; #
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; Z   0; # .
    #(Z is dirty)

    # POP RSP_ into TOS
    Z Z; ?+5 ?+4; RSP_ ?+1; 0 Z; # GADGET:FETCH_NEG
    i1 RSP_; #shrink return stack
    TOS TOS; Z TOS;

    Z Z NEXT_cd

R_at_hd: _fromR_hd 0 2 "R@"
R_at_wd: ? #  from return stack to data stack
R_at_cd:
    # GADGET: PUSH TOS
    TOS Z ;
    n1 NOSP_; #grow stack (NOSP_ goes closer to 0)
    ?+11 ?+10; NOSP_ ?+D; #
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; Z   0; # .
    #(Z is dirty)

    # Fetch RSP_ into TOS
    Z Z; ?+5 ?+4; RSP_ ?+1; 0 Z; # GADGET:FETCH_NEG
    TOS TOS; Z TOS;

    Z Z NEXT_cd

# for DS: 0 PICK is equivalent to DUP, 1 PICK is OVER
# for RS: the arg isn't on the RS, but we still want to mirror the semantics,
# so 0 RPICK == R@
RPICK_hd: R_at_hd 0 5 "RPICK"
RPICK_wd: ? #  from return stack to data stack
RPICK_cd:
    # we want to shrink RS by amount equal to TOS
    # so RSP += TOS
    # so RSP_ -= TOS

    TOS RSP_ ; # shrink RS by amt in TOS
    # fetch RSP_ into T(-)
    T T; ?+5 ?+4;        RSP_   ?+1; 0  T;  # T = -*(RSP)

    TOS Z; Z RSP_ ; # grow RS by TOS to restore

    # Flip picked val into TOS
    TOS TOS; T TOS;

    Z Z NEXT_cd


DUP_hd: RPICK_hd 0 3 "DUP"
DUP_wd: ?
DUP_cd:
    # GADGET: PUSH TOS
    TOS Z ;
    n1 NOSP_; #grow stack (SP_ goes closer to 0)
    ?+11 ?+10; NOSP_ ?+D; #
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; Z   0; # .
    Z Z NEXT_cd

DROP_hd: DUP_hd 0 4 "DROP"
DROP_wd: ?
DROP_cd:
    # GADGET: POP(Z-)
    ?+5 ?+4; NOSP_  ?+1; 0 Z;
    TOS TOS; Z TOS; # copy NOS into TOS(+)
    i1 NOSP_; #shrink stack (SP_ goes more negative)
    Z Z NEXT_cd

_2DROP_hd: DROP_hd 0 5 "2DROP"
_2DROP_wd: ? # drops 2 elements
_2DROP_cd:
    #TOS and NOS can get discarded, but 3OS needs to get popped

    i1 NOSP_; #shrink stack (discard NOS)
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: -@NOSP(Z)
    TOS TOS; Z TOS; # flip Z into TOS+
    i1 NOSP_; #shrink stack (3OS now in TOS)
    Z Z NEXT_cd

SLOW_SWAP_wd: ? # ( a b -- b a )
SLOW_SWAP_cd:
    # GADGET: POPNOS-(Z) (don't change SP)
    ?+5 ?+4; NOSP_  ?+1; 0 Z;

    #Z holds -a
    #TOS holds +b

    T T;     TOS T;
    TOS TOS; Z TOS;

    #TOS holds +a
    #T holds -b

    # GADGET: -!NOS(T) (dont change SP)
    ?+11 ?+10; NOSP_ ?+D; #
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; T   0; # .

    #Swapped
    Z Z NEXT_cd

# We can do better by doing *(NOSP) -= (NOS - TOS)
SWAP_hd: _2DROP_hd 0 4 "SWAP"
SWAP_wd: ? # ( a b -- b a )
SWAP_cd:
    # GADGET: -@NOS(Z) (don't change SP)
    ?+5 ?+4; NOSP_  ?+1; 0 Z;

    #Z holds -a (-NOS)
    #TOS holds +b

    # calculate NOS-TOS
    T T;     TOS T; #T Holds -TOS
    Z T; # T Holds NOS - TOS

    TOS TOS; Z TOS; #TOS holds +a

    #TOS holds +a
    #T holds a-b (NOS-TOS)


    ?+6  ?+5 ; NOSP_ ?+2 ; T 0; # GADGET: SUBNOS(T)
    #Swapped
    Z Z NEXT_cd

OVER_hd: SWAP_hd 0 4 "OVER"
OVER_wd: ? # ( a b -- a b a)
OVER_cd:
    #peek a into Z-
    # GADGET: -@NOS(Z) (don't change SP)
    ?+5 ?+4; NOSP_  ?+1; 0 Z;

    # Push TOS (b) into NOS
    T T; TOS T;
    n1 NOSP_; #grow stack
    ?+11 ?+10; NOSP_ ?+D; # GADGET: -!NOS(T)
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; T   0; # .

    # Put a into TOS
    TOS TOS; Z TOS;
    Z Z NEXT_cd;

_2DUP_hd: OVER_hd 0 4 "2DUP"
_2DUP_wd: do_colon # ( a b -- a b a b) #TODO: upgrade to asm
    OVER_wd OVER_wd EXIT_wd


TUCK_hd: _2DUP_hd 0 4 "TUCK"
TUCK_wd: do_colon # (a b - b a b)
    SWAP_wd OVER_wd EXIT_wd

# We can do better by doing *(NOSP) -= (NOS - TOS)
_2SWAP_hd: TUCK_hd 0 5 "2SWAP"
_2SWAP_wd: ? # ( a b c d -- c d a b )
_2SWAP_cd:

    X X; Y Y; V V;
    # fetch next 3
    ?+5 ?+4; NOSP_  ?+1; 0 V; # GADGET: -@NOS(V)
    i1 NOSP_; #shrink stack (now at 3OS)
    ?+5 ?+4; NOSP_  ?+1; 0 Y; # GADGET: -@NOS(Y)
    i1 NOSP_; #shrink stack (now at 4OS)
    ?+5 ?+4; NOSP_  ?+1; 0 X; # GADGET: -@NOS(X)
    # now  X=-a, Y=-b, V=-c

    # 4OS becomes c, subtract (a-c)
    # 3OS becomes d, subtract (b-d) == (b-tos)
    # NOS becomes a, subtract (c-a)
    # TOS becomes b

    T T; V Z; Z T; #T = -c
    X T; # T = a-c
    ?+6  ?+5 ; NOSP_ ?+2 ; T 0; # GADGET: SUB4OS(T), becomes c

    # need (b-tos)
    Z Z; Y Z; TOS Z; # Z holds (b-tos)
    n1 NOSP_; #grow stack by 1 (now at 3OS)
    ?+6  ?+5 ; NOSP_ ?+2 ; Z 0; # GADGET: SUB4OS(Z), becomes tos == d

    n1 NOSP_; #grow stack by 2 (now at NOS)
    Z Z; T Z; # Z = c-a
    ?+6  ?+5 ; NOSP_ ?+2 ; Z 0; # GADGET: SUBNOS(Z), becomes a

    TOS TOS; Y TOS; # TOS becomes b
    Z Z NEXT_cd

ROT_hd: _2SWAP_hd 0 3 "ROT"
ROT_wd: ? # ( a b tos -- b tos a )
    # Fetch X=-a, Y=-b
    X X; Y Y;
    ?+5 ?+4; NOSP_  ?+1; 0 Y; # GADGET: -@NOS(Y)
    i1 NOSP_; #shrink stack (get to 3OS = a)
    ?+5 ?+4; NOSP_  ?+1; 0 X; # GADGET: -@NOS(X)
    # NOSP points to third-on-stack

    #3os becomes b, subtract (a-b)
    #nos becomes tos, subtract (b-tos)
    # a goes to TOS

    X Y; # Y has (+a - b)
    # NOSP points to third-on-stack
    ?+6  ?+5 ; NOSP_ ?+2 ; Y 0; # GADGET: SUB3OS(Y), 3OS becomes b

    n1 NOSP_; #grow stack, NOSP points to next-on-stack again
    Y Z; TOS Z; # Z has (+b - a - tos)
    X Z; # Z has (b-tos)
    ?+6  ?+5 ; NOSP_ ?+2 ; Z 0; # GADGET: SUBNOS(Z), NOS becomes tos

    TOS TOS; X TOS; #TOS becomes a
    Z Z NEXT_cd

_ROT_hd: ROT_hd 0  4 "-ROT"
_ROT_wd: ? # ( a b tos -- tos a b )
    # Fetch X=-a, Y=-b
    X X; Y Y;
    ?+5 ?+4; NOSP_  ?+1; 0 Y; # GADGET: -@NOS(Y)
    i1 NOSP_; #shrink stack (get to 3OS = a)
    ?+5 ?+4; NOSP_  ?+1; 0 X; # GADGET: -@NOS(X)
    # NOSP points to third-on-stack

    #3os becomes tos, subtract (a-tos)
    #nos becomes a, subtract (b-a)
    #tos becomes b

    X Z; TOS Z; # Z has (a - tos)
    # NOSP points to third-on-stack
    ?+6  ?+5 ; NOSP_ ?+2 ; Z 0; # GADGET: SUB3OS(Z), 3OS becomes tos

    Y X; # X has (b-a)
    n1 NOSP_; #grow stack, NOSP points to next-on-stack again
    ?+6  ?+5 ; NOSP_ ?+2 ; X 0; # GADGET: SUBNOS(X), NOS becomes a

    TOS TOS; Y TOS; #TOS becomes b
    Z Z NEXT_cd

PICK_hd: _ROT_hd 0 4 "PICK"
PICK_wd: ? # ( ... s2 s1 s0 n -- ... s2 s1 s0 s_n )
    # n is in TOS(+)
    # if n == 0, we want to read NOSP[0]
    # for n > 0, we want to go deeper into the stack (higher in mem)

    TOS NOSP_; # NOSP(-) -= n (go towards higher memory addresses, deeper)

    ### fetch NOSP+n into T-
    T T;
    ?+5 ?+4; NOSP_  ?+1; 0 T; # GADGET: @NEGNOS(Z)

    TOS Z; Z NOSP_; # NOSP(-) += n (return to normal)

    # put fetched val in TOS
    TOS TOS; T TOS;

    Z Z NEXT_cd

# ================================================================
#
#                       VARS / CONSTS
#
# ================================================================
# Lost words: do_var, do_const
# BASE STATE DP LATEST
# DO_COLON DO_VAR DO_CONST
# DS0 RS0 NOSP_ RSP_
# TOK_BUFF TOKP

do_var: # push CWA+1
    ### Push TOS into NOS
    T T; TOS T;
    n1 NOSP_; #grow stack
    ?+11 ?+10; NOSP_ ?+D; # GADGET: NEG!NOS(T)
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; T   0; # .

    TOS TOS; CWA Z; Z TOS; n1 TOS; # TOS = CWA+1
    Z Z NEXT_cd

do_const: # push *(CWA+1)
    ### Push TOS into NOS
    T T; TOS T;
    n1 NOSP_; #grow stack
    ?+11 ?+10; NOSP_ ?+D; # GADGET: NEG!NOS(T)
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; T   0; # .

    #ptr(-) in P1
    P1 P1; CWA P1; i1 P1; # P1(-) points to CWA+1
    ?+5 ?+4; P1 ?+1; 0 Z; # GADGET:FETCH Z -= *(-P1)
    TOS TOS; Z TOS;

    Z Z NEXT_cd

# Outer interp vars
BASE_hd: PICK_hd 0 4 "BASE"
BASE_wd:  do_var    BASE_val: 0A
STATE_hd: BASE_hd 0 5 "STATE"
STATE_wd: do_var    STATE_val: 0

# Dict vars
DP_hd: STATE_hd 0 2 "DP"
DP_wd:     do_var       DP_val:    0DEAD #TODO
LATEST_hd: DP_hd 0 6 "LATEST"
LATEST_wd: do_var       LATEST_val: 0DEAD

# Constant, key addresses of lost interpreters
# (others can be gotten using find)
DO_COLON_hd: LATEST_hd 0 8 "DO_COLON"
DO_COLON_wd: do_const       DO_COLON_val: do_colon
DO_VAR_hd: DO_COLON_hd 0 6 "DO_VAR"
DO_VAR_wd:   do_const       do_var
DO_CONST_hd: DO_VAR_hd 0 8 "DO_CONST"
DO_CONST_wd: do_const       do_const

#DO_EXIT_wd: do_const       DO_EXIT_val: EXIT_cd


# Note: when stack is empty, NOSP(-) points to DS0+2
# Note: when stack is empty, RSP(-) points to DS0+1
DS0_hd: DO_CONST_hd 0 3 "DS0"
DS0_wd: do_const  DS0_val: dstack_base

RS0_hd: DS0_hd 0 3 "RS0"
RS0_wd: do_const  RS0_val: rstack_base

NOSP__hd: RS0_hd 0 5 "NOSP_"
NOSP__wd: do_const  NOSP__val: NOSP_

RSP__hd: NOSP__hd 0 4 "RSP_"
RSP__wd:  do_const   RSP__val: RSP_



# TOKEN buffer (note: TOK_BUFF_0 is len, rest is string)
# TOKP points to next free space?
TOK_BUFF_hd: RSP__hd 0 8 "TOK_BUFF"
TOK_BUFF_wd: do_const TOK_BUFF_val: token_buff

TOKP_hd: TOK_BUFF_hd 0 4 "TOKP"
TOKP_wd:     do_var   TOKP_val: 0


restart_wd_addr: 0DEAD # Init will fill this in, since we don't have forward lebels

# Holds xt for exception handler, will get called by handle_exception_x
# (variable, implemented as const because of assembly weirdness)
EXC_HANDLER_hd: TOKP_hd 0 0B "EXC_HANDLER"
EXC_HANDLER_wd: do_const  e_handler_val

# Set to 1 when in an exception, make sure to clear it before restarting
# ( var impl as const)
IN_EXC_hd: EXC_HANDLER_hd 0 6 "IN_EXC"
IN_EXC_wd: do_const  e_in_e

# Other Vars:
# LATEST (defined just before main loop, since is end of dict)

# ================================================================
#
#                   LOST WORDS
#
# ================================================================
# Defines: (LIT, LITSTR)
# LW_LIT LW_LITSTR LW_EXIT

# Reads from NWA, pushes to stack, advances NWA
LIT_wd: ?
LIT_cd:
    # GADGET: PUSH TOS into stack
    TOS Z ;
    n1 NOSP_; #grow stack (SP_ goes closer to 0)
    ?+11 ?+10; NOSP_ ?+D; #
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; Z   0; # .

    Z Z ;

    # Fetch from NWA
    T T; NWA T; #put -ptr into T
    # Fetch(-) into Z
    ?+5 ?+4;        T   ?+1; 0  Z;  # Z = -*(-T)
    TOS TOS; Z TOS; #TOS gets (+) *NWA

    # Increment NWA
    n1 NWA ;

    Z Z NEXT_cd

# String starting at NWA. Pushes strp to stack
# Advances NWA by len+1 to skip string
LITSTR_wd: ?
    # GADGET: PUSH TOS into stack
    TOS Z ;
    n1 NOSP_; #grow stack (SP_ goes closer to 0)
    ?+11 ?+10; NOSP_ ?+D; #
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; Z   0; # .

    Z Z;

    # Copy strp (NWA) to TOS
    T T; NWA T; TOS TOS; T TOS;

    # Fetch strlen from NWA (T- is PTR)
    ?+5 ?+4;        T   ?+1; 0  Z;  # Z = -*(-T)
    # Z holds -strlen

    # increment NWA by strlen + 1
    Z NWA; n1 NWA;

    Z Z NEXT_cd


LW_LIT_hd: IN_EXC_hd 0  6 "LW_LIT"
LW_LIT_wd: do_const LIT_wd

LW_LITSTR_hd: LW_LIT_hd 0  9 "LW_LITSTR"
LW_LITSTR_wd: do_const LITSTR_wd

# TODO: this one isn't actually a lost word?
# I just allow it to be used in all sorts of places
LW_EXIT_hd: LW_LITSTR_hd 0 7 "LW_EXIT"
LW_EXIT_wd: do_const EXIT_wd

LW_TAILCALL_hd: LW_EXIT_hd 0 0B "LW_TAILCALL"
LW_TAILCALL_wd: do_const TAILCALL_wd

# ================================================================
#
#                    ARITHMETIC
#
# ================================================================
# @ ! +! -!
# + - NEG 1+ 2+ 1- 2-
# CSPLIT CJOIN
# * /MOD
# TODO 2* >> << AND OR NOT


_at_hd: LW_TAILCALL_hd 0 1 "@"
_at_wd: ? # ( addr - *addr )
_at_cd:
    P1 P1; TOS P1; # P1(-) = addr

    # Fetch(-) into Z
    ?+5 ?+4;        P1   ?+1; 0  Z;  # Z = -*(-P1)
    TOS TOS; Z TOS; #TOS gets (+)

    Z Z NEXT_cd

_bang_hd: _at_hd 0 1 "!"
_bang_wd: ? # (val addr - [*addr = val] )

    P1 P1; TOS P1; # addr in P1(-)

    X X; # Pop val(-) into X
    ?+5 ?+4; NOSP_  ?+1; 0 X; # GADGET: POP(X-)
    i1 NOSP_; #shrink stack (SP_ goes more negative)

    # Pop 3OS into TOS
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: POP(Z-)
    i1 NOSP_; #shrink stack (SP_ goes more negative)
    TOS TOS; Z TOS;

    # POKE value into ptr
    # GADGET: POKE:
    ?+11 ?+10; P1 ?+D; # *(P1-) = -X
    ?+C  ?+B ; P1 ?+8; # .
    ?+9  ?+8 ; P1 ?+5; # .
    0    0   ; X   0; # .
    Z Z NEXT_cd

_plusbang_hd: _bang_hd 0 2 "+!"
_plusbang_wd: ? # (val addr - [*addr += val] )

    P1 P1; TOS P1; # addr in P1(-)

    X X; # Pop val(-) into X
    ?+5 ?+4; NOSP_  ?+1; 0 X; # GADGET: POP(X-)
    i1 NOSP_; #shrink stack (SP_ goes more negative)

    # Pop 3OS into TOS
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: POP(Z-)
    i1 NOSP_; #shrink stack (SP_ goes more negative)
    TOS TOS; Z TOS;

    # POKESUB X(-) into ptr  ( += val )
    ?+6  ?+5 ; P1 ?+2 ; X 0; # GADGET: POKESUB(P1), *(-P1) -= X

    Z Z NEXT_cd

_minusbang_hd: _plusbang_hd 0 2 "-!"
_minusbang_wd: ? # (val addr - [*addr -= val] )
    P1 P1; TOS P1; # addr in P1(-)

    X X; # Pop val(-) into X
    ?+5 ?+4; NOSP_  ?+1; 0 X; # GADGET: POP(X-)
    i1 NOSP_; #shrink stack (SP_ goes more negative)

    # Pop 3OS into TOS
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: POP(Z-)
    i1 NOSP_; #shrink stack (SP_ goes more negative)
    TOS TOS; Z TOS;

    #flip X,  Z(+) = val
    Z Z; X Z;
    # POKESUB Z(+) into ptr  ( *ptr -= val )
    ?+6  ?+5 ; P1 ?+2 ; Z 0; # GADGET: POKESUB(P1), *(-P1) -= Z

    Z Z NEXT_cd

_plus_hd: _minusbang_hd 0 1 "+"
_plus_wd: ? #( a b -- a+b)
    # ### Pop NOS into Z
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    Z TOS; # TOS -= -a
    Z Z NEXT_cd

_minus_hd: _plus_hd 0 1 "-"
_minus_wd: ? #( a b -- a-b)
    # ### Pop NOS into Z
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    # Z holds -a

    T T; TOS T; T Z; # Z holds b-a
    TOS TOS; Z TOS; # TOS holds a-b
    Z Z NEXT_cd

NEG_hd: _minus_hd 0 3 "NEG"
NEG_wd: ? #( a -- -a)
    T T;
    TOS T; T Z;
    TOS TOS; Z TOS;
    Z Z NEXT_cd

_1plus_hd: NEG_hd 0 2 "1+"
_1plus_wd: ? #( a -- a+1)
    n1 TOS; Z Z NEXT_cd

_2plus_hd: _1plus_hd 0 2 "2+"
_2plus_wd: ? #( a -- a+2)
    n2 TOS; Z Z NEXT_cd

_1minus_hd: _2plus_hd 0 2 "1-"
_1minus_wd: ? #( a -- a-1)
    i1 TOS; Z Z NEXT_cd

_2minus_hd: _1minus_hd 0 2 "2-"
_2minus_wd: ? #( a -- a-2)
    i2 TOS; Z Z NEXT_cd


# ============= BITWISE STUFF

# splits word into 2 bytes, LE on top
CSPLIT_hd: _2minus_hd 0 6 "CSPLIT"
CSPLIT_wd: ? # ( x -- hibyte(x) lobyte(x))
    alu_A alu_A;   TOS Z; Z alu_A; Z Z;  # alu_A := x

    # Get hibyte:
    alu_B alu_B;  n8 alu_B;  # alu_B := 8
    T T; alu_rs T;    # T- = (x >> 8)

    # Push hibyte into NOS
    n1 NOSP_; #grow stack
    ?+11 ?+10; NOSP_ ?+D; # GADGET: NEG!NOS(T)
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; T   0; # .

    # Get lobyte into TOS
    TOS TOS;
    alu_B alu_B;  nF0 alu_B; nF alu_B;  # alu_B := FF
    alu_and Z; Z TOS;                   # TOS = (x & FF)

    Z Z NEXT_cd

# Undoes CSPLIT
CJOIN_hd: CSPLIT_hd 0 5 "CJOIN"
CJOIN_wd: ? # ( hibyte lobyte -- x )

    # ### Pop NOS(hibyte) into Z
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    alu_A alu_A; Z alu_A; Z Z;  # alu_A := hibyte(+)

    # Shift hibyte up
    alu_B alu_B;  n8 alu_B;  # alu_B := 8
    T T; alu_ls T;    # T- = (x << 8)

    # add hibyte into TOS
    T TOS ;

    Z Z NEXT_cd

# AND OR XOR NOT
# << >> A>>
# 2* 2/ 1>>
AND_hd: CJOIN_hd 0 3 "AND"
AND_wd: ? # (a b -- a_AND_b )
    # ### Pop NOS(a) into Z
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    alu_A alu_A; Z alu_A; Z Z;          # alu_A := a
    alu_B alu_B; T T; TOS T; T alu_B ;  # alu_B := TOS(+)
    TOS TOS; alu_and Z; Z TOS;          # TOS = a&b
    Z Z NEXT_cd # (return a&b)

OR_hd: AND_hd 0 2 "OR"
OR_wd: ? # (a b -- a_OR_b )
    # ### Pop NOS(a) into Z
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    alu_A alu_A; Z alu_A; Z Z;          # alu_A := a
    alu_B alu_B; T T; TOS T; T alu_B ;  # alu_B := TOS(+)
    TOS TOS; alu_or Z; Z TOS;           # TOS = a|b
    Z Z NEXT_cd # (return a&b)

XOR_hd: OR_hd 0 3 "XOR"
XOR_wd: ? # (a b -- a_XOR_b )
    # ### Pop NOS(a) into Z
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    alu_A alu_A; Z alu_A; Z Z;          # alu_A := a
    alu_B alu_B; T T; TOS T; T alu_B ;  # alu_B := TOS(+)
    TOS TOS; alu_xor Z; Z TOS;          # TOS = a^b
    Z Z NEXT_cd # (return a&b)

NOT_hd: XOR_hd 0 3 "NOT"
NOT_wd: ? # (a -- ~a )
    alu_A alu_A; T T; TOS T; T alu_A ;  # alu_A := TOS(+)
    alu_B alu_B; i1 alu_B;              # alu_B := FFFF
    TOS TOS; alu_xor Z; Z TOS;          # TOS = a ^ FFFF
    Z Z NEXT_cd # (return ~a)

_lshift_hd: NOT_hd 0 2 "<<"
_lshift_wd: ? # (a b -- a_<<_b )
    # ### Pop NOS(a) into Z
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack
    T T; TOS T;  # T(-) = TOS
_lshift_ZT_cd: # ( alternate entry: shifts Z(-) >> T(-) )
    alu_A alu_A; Z alu_A; Z Z;          # alu_A := a
    alu_B alu_B; T alu_B ;              # alu_B := TOS(+)
    TOS TOS; alu_ls Z; Z TOS;           # TOS = a<<b
    Z Z NEXT_cd # (return a<<b)

_2mul_hd: _lshift_hd 0 2 "2*"
_2mul_wd: ? # ( a -- a<<1 )
    # we'll call into _lshift, will do Z- (a) << T- (1)
    TOS Z;  # Z- := a
    T T; i1 T _lshift_ZT_cd  # T(-) = 1, jump

# LOGICAL (unsigned) RIGHT SHIFT
U_rshift_hd: _2mul_hd 0 3 "U>>"
U_rshift_wd: ? # (a b -- a_U>>_b )
    # ### Pop NOS(a) into Z
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack
    T T; TOS T;  # T(-) = TOS
U_rshift_ZT_cd: # ( alternate entry: shifts Z(-) U>> T(-) )
    alu_A alu_A; Z alu_A; Z Z;          # alu_A := a
    alu_B alu_B; T alu_B ;              # alu_B := TOS(+)
    TOS TOS; alu_rs Z; Z TOS;           # TOS = a>>b
    Z Z NEXT_cd # (return a>>b)

_1U_rshift_hd: U_rshift_hd 0 4 "1U>>"
_1U_rshift_wd: ? # ( a -- aU>>1 )
    # we'll call into U_rshift, will do Z- (a) >> T- (1)
    TOS Z;  # Z- := a
    T T; i1 T U_rshift_ZT_cd  # T(-) = 1, jump

# ARITHMETIC RIGHT SHIFT
_rshift_hd: _1U_rshift_hd 0 2 ">>"
_rshift_wd: ? # (a b -- a_>>_b )
    # ### Pop NOS(a) into Z
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack
    T T; TOS T;  # T(-) = TOS
_rshift_ZT_cd: # ( alternate entry: shifts Z(-) >> T(-) )
    alu_A alu_A; Z alu_A; Z Z;          # alu_A := a
    alu_B alu_B; T alu_B ;              # alu_B := TOS(+)
    TOS TOS; alu_ars Z; Z TOS;          # TOS = a>>b
    Z Z NEXT_cd # (return a<<b)

# NOTE: rounds down if negative
_2div_hd: _rshift_hd 0 2 "2/"
_2div_wd: ? # ( a -- a>>1 )
    # we'll call into _rshift, will do Z- (a) >> T- (1)
    TOS Z;  # Z- := a
    T T; i1 T _rshift_ZT_cd  # T(-) = 1, jump


_times_exit: # We jump here once X==0
    # NOTE: Z was clobbered before jump
    TOS TOS; V Z; Z TOS; # Result in V(+), copy to T
    Z Z NEXT_cd

# ================== TIMES ENTRY POINT
_times_hd: _2div_hd 0 1 "*"
_times_wd: ? # (x y - x*y )

    alu_B alu_B; n1 alu_B; # alu_B is always 1

    # X and Y hold negatives, so ALU holds positives
    X X ;  # X(-) holds A,
    Y Y ;  TOS Y; # Y(-) holds B
    V V; # Sum(+) in V

    # Pop val(-) into X
    ?+5 ?+4; NOSP_  ?+1; 0 X; # GADGET: POP(X-)
    i1 NOSP_; #shrink stack (SP_ goes more negative)

_times_loop:
    alu_A alu_A; X alu_A; # alu(+) gets A

#==== if X & 1, SUM += Y
    T T; alu_and T ; # T = -(A&1)
    T Z ?+3 # if A&1 <= 0, skip

    Y V ; # else A&1 == 1, SUM(+) -= Y(-), add val to SUM
    Z Z ; # unclobber Z

#==== X >> 1, Y<<1
    X X; alu_rs X; # X(-) = a>>1,

    alu_A alu_A; Y alu_A; # alu(+) gets Y(-)
    Y Y; alu_ls Y; # Y(-) = b<<1

#==== if X == 0, exit
    Z X ?+3         # if     X<= 0, nextif
    Z Z ?+3         # else   X > 0, skip
    X Z _times_exit # nextif X >= 0, so x == 0, so exit
                    # else   x <> 0
    Z Z _times_loop
# else, jump loop:


_divby0: # jump to exception
    Z Z except5

U_divmod_ret_0: # Return quotient 0 remainder 0
    W W; X X; V V; P1 P1;
U_divmod_exit: # We jump here once X==0
    # W = 0
    # X = remainder
    # V(-) = quotient
    # Y would be divisor>>1, but we exited early
    # P1 holds sign (nonzero means -)


    # TODO: if P1, flip V, X
    # P1 is -1, 0, or +1. 0 means no flip needed

    # if p1 > 0, p1 -= 2
    Z P1 ?+3    #if P1 <= 0, skip
    i2 P1 ; # else (P1>0), P1-=2
    # Now P1 is 0(noflip) or -1 (flip)

    n1 P1 ; # Now is 1(noflip) or 0(flip)

    #Quotient in V(-), Remainder in X(+)

    Z P1 ?+3 # If P1=0 (flip)
    Z Z ?+24 # else, skip
        T T; V Z; Z T; V V; T V; Z Z;  # Flip V (quotient)
        T T; X Z; Z T; X X; T X; Z Z;  # Flip X (remainder )

    # ### Push quotient (in V(-))  into NOS
    n1 NOSP_; #grow stack
    ?+11 ?+10; NOSP_ ?+D; # GADGET: NEG!NOS(T)
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; V   0; # .


    # Remainder in X(+)
    Z P1 ?+3 # If P1=0 (flip, Copy X-)
    Z Z ?+09 # else, skip, copy X+
        TOS TOS; X TOS; # Flip X, so Copy X- to TOS
        Z Z NEXT_cd
    # else
        TOS TOS; X Z; Z TOS; # Remainder in X(+), copy to TOS
        Z Z NEXT_cd

# ================ DIVMOD ENTRY POINT
U_divmod_hd: _times_hd 0 5 "U/MOD"
U_divmod_wd: ? # (x y - x/y x%y )

    alu_B alu_B; n1 alu_B; # alu_B is always 1

    # TODO: can optimize by assigning flipped X&Y, since
    # we explicitly handle their signs anyway

    # X and Y hold positives,
    X X ;  # X holds A (remainder),
    Y Y ; T T; TOS T; T Y; # Y holds B (divisor)
    V V ; # Quotient(-) in V
    W W; n1 W; # multiplier, starts at 1

    P1 P1; # P1 will hold sign bit, = +1/-1 if negative, 0 if positive

    # Flip Y to positive, if Y == 0, error out?
    Z Y ?+3 # if Y <= 0: nextif
    Z Z ?+12 # else Y>0: continue to endif (6 ops, 18words)
    Y Z _divby0 # nextif Y>=0 (Y==0) exception, divide by 0
    # nextelse: Y < 0: flip Y,
        Y Y; T T; Z T; T Y; i1 P1; #flip Y, P1--
    # endif
    Z Z ;

    # Pop val(+) into X
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: POP(Z-)
    Z X; Z Z;
    i1 NOSP_; #shrink stack (SP_ goes more negative)



    ### TODO TEMP DEBUG: leave X (n, dividend) as -, we're going to do unsigned div )
    # ==== OLD CODE: ( flip dividend positive, signed divide )
    # # Flip X to positive, flip sign bit
    # X Z ?+0F #if X >= 0 skip (5ops, 15words=0x0F)
    # # else: X < 0
    #     X X; T T; Z T; T X; n1 P1; #P1++
    # #endif
    # Z Z ;

    # === NEW CODE: If X == 0: return 0, else continue ( no flip)
    T T;
    X  T ?+3 # if T <= 0; nextif
    Z  Z ?+6 # KNOW:>0, jmp GTZ
    n1 T ?+3 # nextif T+1<=0 (KNOW:T<0, jmp LTZ):
    Z Z U_divmod_ret_0  # KNOW: T==0==X, return 0,0




    # Lshift Y and multiplier until they hit the left side (<0)
    # actually, only need to shift until Y >= X
    # then Y-X >= 0, and won't overflow!
    # Proof (consider 4bit)
    #  X = 0b0111, Y = 0b0111, match, wont shift higher
    #  X = 0b0111, Y = 0b0110, shifts up
    #              Y = 0b1100, match, difference is 3, 0b0011
    #  X = 0b0100, Y = 0b0011, shifts up
    #              Y = 0b0110, match, difference is 2, 0b0010
    #  X = 0b0101, Y = 0b0100, shifts up
    #              Y = 0b1000, match, difference is 4, 0b0100
    #

    #NOTE: want to handle case where x < 0 (i.e. x in 0x8000-0xFFFF)

U_divmod_loop1:
    # OLD LOGIC: loop until Y(div) >= X(n) ( checked as X-Y<=0 ), break
    # OLD LOGIC breaks if e.g. Y is negative,
    #Q1 Q1; Y Q1; # temp: Q1 = -Y
    #T T; X T; Q1 T; # T = Y-X
    #T Z ?+1B # if X-Y<=0 (Y>=X), break

    # NEW Logic: loop until Y(div) has high bit set (i.e.)<= 0
    # NOTE: we must have already check for Y=0 above
    Q1 Q1; Y Q1; # Temp, q1=-Y (needed for doubling)
    Z Y ?+1b # If Y<=0, break


    #else: double Y, double mult
    Z Z; Y Y; Q1 Y; Q1 Y; #12 words
    W Z; W W; Z W; Z W; Z Z U_divmod_loop1 # 15 words, total 27 = 0x1B

    # endloop
    Z Z;

    # Now: since we've guaranteed both X and Y originally >0, Y wont have overflowed.
    # Y may be negative, but Y-X >= 0

    alu_B alu_B; n1 alu_B; # Always shifting by 1

    # NOTE: if X > 0 (i.e. high bit not set,)
    # we need to skip an iteration (i.e 1>> Y, mult)
    Z X ?+3 # If X<=0, start normally
    Z Z ?+18 # Else, X>0: skip an iteration

U_divmod_loop2:
    #if Y <= X (Y-X <= 0)
    #  X -= Y
    #  Quot+= mult

    Y X; X Z ?+C # X-=Y; if result >= 0 (i.e. Y was <= X), if succeeds
        T T; Y T; T X;  # else, undo that
        Z Z ?+6         # skip to endif
    # (if succeeded)
        Z Z; W V; # Quotient(-) += Mult
    # endif

    # Y >> 1, mult >> 1
    # NOTE: if W<=0, exit
    #          W can't be negative, since we have rightshifted it at least once
    #          therefore we exit once it hits 0
    T T; alu_A alu_A; W T; T alu_A; W W; T T; alu_rs T; T W U_divmod_exit
    T T; alu_A alu_A; Y T; T alu_A; Y Y;      alu_rs Z; Z Y;
    Z Z U_divmod_loop2




#==== if X & 1, SUM += Y
    T T; alu_and T ; # T = -(A&1)
    T Z ?+3 # if A&1 <= 0, skip

    Y V ; # else A&1 == 1, SUM(+) -= Y(-), add val to SUM
    Z Z ; # unclobber Z

#==== X >> 1, Y<<1
    X X; alu_rs X; # X(-) = a>>1,

    alu_A alu_A; Y alu_A; # alu(+) gets Y(-)
    Y Y; alu_ls Y; # Y(-) = b<<1

#==== if X == 0, exit
    Z X ?+3         # if     X<= 0, nextif
    Z Z ?+3         # else   X > 0, skip
    X Z U_divmod_exit # nextif X >= 0, so x == 0, so exit
                    # else   x <> 0
    Z Z U_divmod_loop2
# else, jump loop:



# _divmod_hd: U_divmod_hd 0 4 "/MOD"
# _divmod_wd: do_colon # ( a b -- )
#     # Does signed division: if a < 0: negates A, does divmod, then swaps back
#     OVER 0<
#     HALT1_wd

# ================================================================
#
#                        CONTROL FLOW
#
# ================================================================
# = <> < >=
# 0= 0<> 0> 0<= 0<
# <= >
# ( BRANCH 0BRANCH )
# LW_BRANCH LW_0BRANCH

# Set TOS to 0/1, return to NEXT_cd
_cmp_ret_f:
    TOS TOS; Z Z NEXT_cd
_cmp_ret_t:
    TOS TOS; n1 TOS; Z Z NEXT_cd


# NOTE: All comparisons fall through to their 0 versions, therefore their
# headers are separate and point to the code bodies

_eq_hd: U_divmod_hd 0 1 "="
_eq_wd: ? # ( a b  -  a==b?1:0)
    # ### Pop NOS, subtract from TOS
    ?+5 ?+4; NOSP_  ?+1; 0 TOS; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    #TOS is b-a, fallthru to 0eq
_0eq_cd:
    Z  TOS ?+3 # if T <= 0; nextif
    Z  Z   _cmp_ret_f # KNOW:>0, jmp GTZ
    n1 TOS _cmp_ret_f # nextif T+1<=0 (KNOW:T<0, jmp LTZ):
    # Know: TOS==0, return true
    TOS TOS; n1 TOS; Z Z NEXT_cd # return 1


_ne_hd: _eq_hd 0 2 "<>"
_ne_wd: ? # ( a b  -  a!=b?1:0)
    # ### Pop NOS, subtract from TOS
    ?+5 ?+4; NOSP_  ?+1; 0 TOS; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    #TOS is b-a
_0ne_cd:
    Z  TOS ?+3 # if T <= 0; nextif
    Z  Z   _cmp_ret_t # KNOW:>0, jmp GTZ
    n1 TOS _cmp_ret_t # nextif T+1<=0 (KNOW:T<0, jmp LTZ):
    # else, KNOW: TOS==0
    TOS TOS NEXT_cd # return 0

U_lt_hd: _ne_hd 0 2 "U<"
U_lt_wd: ? # ( a b - a<b?1:0)
    # Like <, except here, 1 < FFFF
    # ### Pop NOS into X
    X X; Y Y; T T;
    ?+5 ?+4; NOSP_  ?+1; 0 T; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack
    T X; T Y; # X = a, Y=a
    TOS Y ; # Y = a-b

    # Q1 / Q2 will be 1 if a/b are NEGATIVE (<0)
    Q1 Q1; Q2 Q2;

    # Check a<0
    Z  X ?+3 # if a <= 0; nextif
    Z  Z ?+9 # KNOW:>0, skip
    n1 X ?+3 # nextif a+1<=0 (KNOW:a<0, jmp LTZ):
    Z Z  ?+3 # KNOW: a==0, skip
    n1 Q1;   # LTZ: a<0, Q1=TRUE

    # Check b<0
    Z  TOS ?+3 # if b <= 0; nextif
    Z  Z   ?+9 # KNOW:>0, skip
    n1 TOS ?+3 # nextif b+1<=0 (KNOW:b<0, jmp LTZ):
    Z Z    ?+3 # KNOW: b==0, skip
    n1 Q2;     # LTZ: b<0, Q2=TRUE

    # NOW: check signs (Q1=0 means a is positive)
    Z Q1  ?+6        # if Q1=0, skip

    Z Q2  _cmp_ret_f # (Q1=1,a<0):  if Q2=0,b>=0 (a-, b+) so (a big, b sml) RETURN FALSE
    Z Z   ?+6        #              else:   b<0  (a-, b-) so (a big, b big) continue

    Z Q2  ?+3        # (Q1=0,a>=0): if Q2=0,b>=0 (a+, b+) so (a sml, b sml) continue
    Z Z   _cmp_ret_t #              else:   b<0  (a+, b-) so (a sml, b big) RETURN TRUE
                     #
    # Signs match, do comparison
    # Y = a-b, Y != 0x8000
    # we want a<b, which is b>a, which is b-a>0
    Y Z ?+3 # flip Y, b-a<=0: skip
    Z Z _cmp_ret_t # else, b-a>0, a<b, TRUE

    # ELSE:
    Z Z _cmp_ret_f

# ===================================================
# ALTERNATIVELY:
# Ignore 0x8000, do sign check, THEN check if difference = 0x8000
# If so, we know it's exactly 0 and 0x8000, (since signs matched),
# can just jump back into sign checks?

    Z X   ?+6        # if a<= 0, skip
    Z TOS _cmp_ret_f # (a>0):  if b<= 0: (a+, b-) so (a sml, b big) jump_ret TURE
    Z Z   ?+6        #         else:     (a+, b+) so (a sml, b sml) continue

    # Check signs ( NOTE: - means large (0x8000-FFFF), + means small)
    # Also note, we want 0 to count as small, so shift things (+1)
    #                 0    becomes 1,    >0,  small
    #                 7FFE becomes 7FFF, >0,  small
    #                 7FFF becomes 8000, <=0, big
    #                 8000 becomes 8001, <=0, big
    #                 FFFE becomes FFFF, <=0, big
    #                 FFFF becomes 0,    <=0, big
    n1 X; n1 TOS; # a++, b++

    Z X   ?+6        # if a<= 0, skip
    Z TOS _cmp_ret_f # (a>0):  if b<= 0: (a+, b-) so (a sml, b big) jump_ret TURE
    Z Z   ?+6        #         else:     (a+, b+) so (a sml, b sml) continue

    Z TOS ?+3        # (a<=0): if b<= 0: (a-, b-) so (a big, b big) continue
    Z Z   _cmp_ret_t #         else:     (a-, b+) so (a big, b sml) jump_ret FALSE

    # # Signs match: do b-a (TOS-=NOS)

    #NOTE: we could have diff=0x8000, so can't tell from sign
    # Check if difference is == 0x8000
    # if it is, (originally 7FFF(>0) and FFFF(<=0), with shift 8000(<=0) and 0(<=0))
    # sub 1 from a and b, redo the sign test, so they're guaranteed to be caught

    X TOS;

_lt_hd: U_lt_hd 0 1 "<"
_lt_wd: ? # ( a b  -  a<b?1:0)
    # Note: main alg is a-b < 0:
    # However, this won't work if A and B are far apert
    # (e.g. A=7000, B=-7000. Signed, A should be > B,
    #  but this comparison takes the shorter direction, so
    #  A-B = -2000 (A as 7000, B as 9000))
    #  We'll call this a feature: this < works both signed
    #  and unsigned, as long as A and B are within 0x8000 of each
    #  other in whatever reference frame you're using

    # ### Pop NOS, subtracting from TOS
    ?+5 ?+4; NOSP_  ?+1; 0 TOS; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    #TOS is b-a
_0gt_cd: # for 0-comparison, TOS is a-0, so is gt instead of lt
    # a<b iff b-a>0
    Z TOS _cmp_ret_f # if     b-a <= 0, b<=a,  a>=b nextif
    Z   Z _cmp_ret_t # else   b-a > 0 , b > a, a<b skip
    # # b <= a
    #     TOS TOS; #TOS = 0
    #     Z Z NEXT_cd
    # # b > a
    #     TOS TOS; n1 TOS; #TOS = 1
    #     Z Z NEXT_cd


_ge_hd: _lt_hd 0 2 ">="
_ge_wd: ? # ( a b  -  a>=b?1:0)
    # ### Pop NOS, subtract from TOS
    ?+5 ?+4; NOSP_  ?+1; 0 TOS; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    #TOS is b-a

_0le_cd: # for 0-comparison, TOS is a-0, so is le instead of ge
    # a>=b iff b-a<=0
    Z TOS _cmp_ret_t # if     b-a <= 0, b<=a, a>=b nextif
    Z   Z _cmp_ret_f # else   b-a > 0 , b >a, a<b  skip
    # b <= a
        TOS TOS; n1 TOS; #TOS = 1
        Z Z NEXT_cd
    # b > a
        TOS TOS; #TOS = 0
        Z Z NEXT_cd



# 0-comparisons are fallthroughs of the main paths, so write their headers here
# TODO: HEADERS
_0eq_hd: _ge_hd 0 2 "0="
_0eq_wd: _0eq_cd

_0ne_hd: _0eq_hd 0 3 "0<>"
_0ne_wd: _0ne_cd

# = link up
_0gt_hd: _0ne_hd 0 2 "0>"
_0gt_wd: _0gt_cd

_0le_hd: _0gt_hd 0 3 "0<="
_0le_wd: _0le_cd

# Define in reference to the above (this is slower, but safer)
_0ge_hd: _0le_hd 0 3 "0>="
_0ge_wd: ?
    # Can't just `NEG 0<=`, since 0x8000 doesn't negate
    Z TOS ?+3     # If a <= 0, skip
    Z Z _cmp_ret_t # else (a>0), TRUE
    # -------- (a<=0) :
    n1 TOS _cmp_ret_f  # a+1 <=0, thfr a < 0, FALSE
    Z    Z _cmp_ret_t # else, a==0, is >=, TRUE

_0lt_hd: _0ge_hd 0 2 "0<"
_0lt_wd: ?
    # Can't just `NEG 0>`, since 0x8000 doesn't negate
    Z TOS ?+3     # If a <= 0, skip
    Z Z _cmp_ret_f # else (a>0), FALSE
    # -------- (a<=0) :
    n1 TOS _cmp_ret_t  # a+1 <=0, thfr a < 0, TRUE
    Z    Z _cmp_ret_f # else, a==0, not <, FALSE

_le_hd: _0lt_hd 0 2 "<="
_le_wd: do_colon
    SWAP_wd _ge_wd EXIT_wd

_gt_hd: _le_hd 0 1 ">"
_gt_wd: do_colon
    SWAP_wd _lt_wd EXIT_wd


BRANCH_wd: ? # NWA += *(NWA)
BRANCH_cd:
    #ptr(-) in P1
    P1 P1; NWA P1; # P1(-) points to NWA
    ?+5 ?+4; P1 ?+1; 0 Z; # GADGET:FETCH Z -= *(-P1)

    # Z = -offset
    Z NWA; # NWA += offset;
    Z Z NEXT_cd

_0BRANCH_wd: ? # If 0, jump BRANCH_cd
    ### Pop NOS into Z
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    T T; TOS T; #TOS in T(-)

    TOS TOS; Z TOS; #NOS+ into TOS
    Z Z;

    Z  T ?+3 # if T <= 0; nextif
    Z  Z ?+6 # KNOW:>0, jmp GTZ
    n1 T ?+3 # nextif T+1<=0 (KNOW:T<0, jmp LTZ):
             # else KNOW: T==0
    # T==0, take_branch
    Z Z BRANCH_cd #(need extra op to clear Z)

    #Else: T<>0, step over offset
    n1 NWA;
    Z Z NEXT_cd


DO_wd: ?
DO_cd:
# data stack looks like : ( end I -- )
# move both to return stack ( RS: end I -- )
    n2 RSP_ ; #grow return stack by 2 ( need to swap order )

    T T; TOS T;
    # GADGET: POKE +TOS to RSP
    ?+11 ?+10; RSP_ ?+D; # *(RSP) = -X
    ?+C  ?+B ; RSP_ ?+8; # .
    ?+9  ?+8 ; RSP_ ?+5; # .
    0    0   ; T   0; # .

    ### Pop NOS into T(-)
    T T;
    ?+5 ?+4; NOSP_  ?+1; 0 T; # GADGET: @NEGNOS(T)
    i1 NOSP_; #shrink stack


    # ( now need to put NOS into swapped place on RS )
    i1 RSP_ ; # shrink stack temporarily

    # GADGET: POKE T(-) to RSP
    ?+11 ?+10; RSP_ ?+D; # *(RSP) = -X
    ?+C  ?+B ; RSP_ ?+8; # .
    ?+9  ?+8 ; RSP_ ?+5; # .
    0    0   ; T   0; # .

    n1 RSP_ ; #grow return stack again to enclose both values

    ### Pop 3OS into TOS
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: -@NOSP(Z-)
    TOS TOS; Z TOS; # copy NOS into TOS(+)
    i1 NOSP_; #shrink stack (SP_ goes more negative)

    Z Z NEXT_cd



_plusLOOP_wd: ?
_plusLOOP_cd:
    # DS: ( inc -- )
    # RS: ( end I -- [end I+inc] or [] )

    T T; TOS T; # add inc to I ( via T(-))
    ?+6  ?+5 ; RSP_ ?+2 ; T 0; # GADGET: POKESUB, *(RSP) -= T

    # Pop NOS into TOS
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # pop NOS into Z(-)
    TOS TOS; Z TOS; # copy NOS into TOS(+)
    i1 NOSP_; #shrink stack (SP_ goes more negative)
    Z Z;

    # fetch -(I) into X
    X X; ?+5 ?+4;        RSP_   ?+1; 0  X;  # X = -*(RSP)

    # fetch -(end) into T
    i1 RSP_ ; # shrink stack to scoot back to `end`
    T T; ?+5 ?+4;        RSP_   ?+1; 0  T;  # T = -*(RSP)
    n1 RSP_ ; # grow stack to where it should be

    # WE WANT:
    #   I end < IF BRANCH ELSE endloop THEN
    # so:
    #   I end < IF BRANCH
    #   I end >= IF endloop
    #   end I <= IF endloop
    #   end I - 0<= IF endloop

    # calc `(end-I)`
    # if (end-I) LEQZ, === I >= end, break out of loop
    T X ?+3 #
        Z Z BRANCH_cd # else: continue

    # I >= end: break out
    n1 NWA ; # step over offset
    i2 RSP_ ; # drop end and I
    Z Z NEXT_cd

_minusLOOP_wd: ?
_minusLOOP_cd:
    # same as +LOOP: except we subtract TOS, and, exit when I <= end

    # SUB inc from I
    ?+6  ?+5 ; RSP_ ?+2 ; TOS 0; # GADGET: POKESUB, *(RSP) -= T

    # Pop NOS into TOS
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # pop NOS into Z(-)
    TOS TOS; Z TOS; # copy NOS into TOS(+)
    i1 NOSP_; #shrink stack (SP_ goes more negative)
    Z Z;

    # fetch -(I) into X
    X X; ?+5 ?+4;        RSP_   ?+1; 0  X;  # X = -*(RSP)

    # fetch -(end) into T
    i1 RSP_ ; # shrink stack to scoot back to `end`
    T T; ?+5 ?+4;        RSP_   ?+1; 0  T;  # T = -*(RSP)
    n1 RSP_ ; # grow stack to where it should be

    # WE WANT:
    #   I end > IF BRANCH ELSE endloop THEN
    #   I end <= IF endloop
    #   I end - 0<= IF endloop

    # calc `(I-end)`
    # if (I-end) LEQZ, === I <= end, break out of loop
    X T ?+3 #
        Z Z BRANCH_cd # else: continue

    # I <= end: break out
    n1 NWA ; # step over offset
    i2 RSP_ ; # drop end and I
    Z Z NEXT_cd


I_from_hd: _gt_hd 0  2 "I>"
I_from_wd: R_at_cd
# I is at the top of RS, so R@ is sufficient

J_from_hd: I_from_hd 0  2 "J>"
J_from_wd: ?
    # `2 rpick`, but let's be a little fancier and specialize it explicitly

    ### Push TOS into NOS
    T T; TOS T;
    n1 NOSP_; #grow stack
    ?+11 ?+10; NOSP_ ?+D; # GADGET: NEG!NOS(T)
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; T   0; # .

    TOS TOS; n2 TOS; # TOS = 2
    Z Z RPICK_cd


# Add constants to capture BRANCH and 0BRANCH
LW_BRANCH_hd: J_from_hd 0  9 "LW_BRANCH"
LW_BRANCH_wd: do_const BRANCH_wd

LW_0BRANCH_hd: LW_BRANCH_hd 0 0A "LW_0BRANCH"
LW_0BRANCH_wd: do_const _0BRANCH_wd

LW_DO_hd: LW_0BRANCH_hd 0 05 "LW_DO"
LW_DO_wd: do_const DO_wd

LW_plusLOOP_hd: LW_DO_hd 0 08 "LW_+LOOP"
LW_plusLOOP_wd: do_const _plusLOOP_wd

LW_minusLOOP_hd: LW_plusLOOP_hd 0 08 "LW_-LOOP"
LW_minusLOOP_wd: do_const _minusLOOP_wd

# ================================================================
#
#                        I/O and STRINGS
#
# ================================================================
# KEY EMIT SPACE NL
# TOKEN
# STRCHARS STR= TELL
# MEMCPY STRCPY
# DIGIT NUMBER


KEY_hd: LW_minusLOOP_hd 0 3 "KEY"
KEY_wd: ? # Fetches in a char (buffers through C_)
    # IF EOF, halts

    ### Push TOS into NOS
    T T; TOS T;
    n1 NOSP_; #grow stack
    ?+11 ?+10; NOSP_ ?+D; # GADGET: NEG!NOS(T)
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; T   0; # .

    # We might have pushed back a character previously, check for that
    Z C_needs_fetch ?+6
        C_ C_; IN C_;  # if needs_fetch=1, fetch a fresh char
    # Else, use the one from C_

    # Put char into TOS
    TOS TOS; C_ TOS;

    # Mark needs_fetch=1, since we consumed the char from it
    C_needs_fetch C_needs_fetch;
    n1 C_needs_fetch ; #needs_fetch=1

    # check for EOF (<0)
    n1 TOS haltE #if TOS+1 <= 0, char was -1
    i1 TOS;        #else, decrement it back

    Z Z NEXT_cd


EMIT_hd: KEY_hd 0 4 "EMIT"
EMIT_wd: ? #Emits char at TOS
EMIT_cd:
    T T; TOS T; T OUT;

    # GADGET: POP(Z-)
    ?+5 ?+4; NOSP_  ?+1; 0 Z;
    TOS TOS; Z TOS; # copy NOS into TOS(+)
    i1 NOSP_; #shrink stack (SP_ goes more negative)

    Z Z NEXT_cd;

SPACE_hd: EMIT_hd 0 5 "SPACE"
SPACE_wd: ?  # Emits 0x20 ' '
SPACE_cd:
    n20 OUT; Z Z NEXT_cd

NL_hd: SPACE_hd 0 2 "NL"
NL_wd: ?  # Emits 0xA '\n'
NL_cd:
    nA OUT; Z Z NEXT_cd

HALT1_wd: ?
HALT1_cd:
    0 0 halt1



# NOTE: token buffers/ptrs with VARS/CONSTS

# VARS:
# TOKP resets to TOK_BUFF
#  VARS
#  Y(-) holds len
#  P1(-) pts to next free space for char, (starts at TOK_BUFF)
#  fetch char into X


# Reached EOF, halt
TOKEN_cd_eof: Z Z haltE

# Skip comments until we hit \n?
TOKEN_cd_comment: #TODO
    Z Z except6






TOKEN_cd_end:
    # We've poked all our chars in
    # Write TOKP
    TOKP_val TOKP_val; P1 TOKP_val;

    # Write len to token_buff[0] (Y is (-))
    token_buff token_buff; Y token_buff;

    #=== Return (token_buff -- )

    ### Push TOS into NOS
    T T; TOS T;
    n1 NOSP_; #grow stack
    ?+11 ?+10; NOSP_ ?+D; # GADGET: NEG!NOS(T)
    ?+C  ?+B ; NOSP_ ?+8; # .
    ?+9  ?+8 ; NOSP_ ?+5; # .
    0    0   ; T   0; # .

    # Put addr of token_buff into TOS
    TOS TOS; TOK_BUFF_val Z; Z TOS;
    Z Z NEXT_cd #EXIT



# We got a token starting with \n
# Push just that token, then return thru TOKEN_cd_end
# mark C_needs_fetch=1, since we don't keep the \n
TOKEN_cd_newline:
    # Poke into string pointer at P1
    # GADGET: POKE-:
    ?+11 ?+10; P1 ?+D; # *(P-) = -C(-)
    ?+C  ?+B ; P1 ?+8; # .
    ?+9  ?+8 ; P1 ?+5; # .
    0    0   ; C_   0; # .

    # Note: we don't want to keep the \n for next time,
    C_needs_fetch C_needs_fetch;
    n1 C_needs_fetch ; #needs_fetch=1
    C_ C_;

    i1 Y;  # inc length (-)
    i1 P1; # advance ptr P1(-)

    Z Z TOKEN_cd_end

# We finished reading a normal token that ended with a separator
# We want to push back the separator for later use,
# then return thru CD_end
TOKEN_cd_endtoken:

    # The last separator char is in C_,
    # mark needs_fetch=0
    C_needs_fetch C_needs_fetch TOKEN_cd_end




# We've skipped all the preceding blanks, now go grab the actual token
TOKEN_cd_readchars:
    #Got a token char in C_, push it to the str

    # Poke into string pointer at P1
    # GADGET: POKE-:
    ?+11 ?+10; P1 ?+D; # *(P-) = -C(-)
    ?+C  ?+B ; P1 ?+8; # .
    ?+9  ?+8 ; P1 ?+5; # .
    0    0   ; C_   0; # .

    i1 P1; # advance ptr P1(-)
    i1 Y;  # inc length (-)

    # just pushed C_, get next char
    C_ C_; IN C_;
    X X; C_ X; # X(+) = C(-)

    # Test value by repeatedly subtracting and testing <= 0
    # - Keep grabbing chars until we hit a space or \n
    n1  X TOKEN_cd_eof        #  : $-1 X halt eof            # char <= -1, == EOF
    i1  X  ?                  #  : $1  X                     #
    i20 X TOKEN_cd_endtoken   #  : $20 X end                 # <=20, ' ' or \n or nonprint
    Z   Z TOKEN_cd_readchars  #  :                           # >20, poke it in, continue


# =============== TOKEN ENTRY POINT (need to jump backwards for labels to work)
TOKEN_hd: NL_hd 0 5 "TOKEN"
TOKEN_wd: ? # Reads a token from IN
            # Skips blanks and control characters
            # Once finds a text char, consume that until next blank, read into tok_buff
            # return strp

    Y Y; # len(-) = 0
    P1 P1; TOK_BUFF_val P1; i1 P1; #P1 points to token_buff[1] (first string char)

    # Loop, repeatedly skipping comments and blanks until we find a char

    # NOTE: Between invocations of TOKEN, we might have pushed back a char
    # - After this point, C_ will be valid
    # - MAKE SURE we set C_needs_fetch correctly when we exit TOKEN
    Z C_needs_fetch ?+6  # If !needs_fetch, skip fetching
TOKEN_cd_lstrip:
    C_ C_; IN C_; # Get next char (skip first time)

    #First copy it into X(+)
    X X; C_ X; # X(+) = C(-)

    # Test value by repeatedly subtracting and testing <= 0
    # - discard all leading spaces
    # - if we get a newline before any token chars, special case it
    # - otherwise go to normal token parsing
    n1  X TOKEN_cd_eof        #  : $-1 X haltEOF             # char <= -1, == EOF
    i1  X  ?                  #  : $1  X                     # ( undo -1 )
    i8  X TOKEN_cd_readchars  #  : $8  X default             # <=08,
    i1  X TOKEN_cd_lstrip     #  : $1  X default             # <=09, '\t'
    i1  X TOKEN_cd_newline    #  : $10 X newline             # <=0A, '\n'
    i10 X  ?                  #                              #  (1A)
    i5  X TOKEN_cd_readchars  #  : $5  X default             # <=1F,
    i1  X TOKEN_cd_lstrip     #  : $1  X skip_spaces         # <=20, ' '
     Z  Z TOKEN_cd_readchars  #  :  Z  Z default             # >20

    #shouldn't reach here
    0d 0d 0d


# TOKEN:
# skips ' ', '\t', '\n'
# consumes chars until blank

STRCHARS_hd: TOKEN_hd 0 8 "STRCHARS"
STRCHARS_wd: do_colon # (strp -- -1 [all chars of string, first char on TOS] )
    LIT_wd 0FFFF SWAP_wd # Push flag ( -1 strp )

    #Get len
    DUP_wd _at_wd SWAP_wd #(-1 len strp)

    #Start at last char, strp+len (don't need to -1 since str[0] is len field)
    OVER_wd _plus_wd  # (-1 len strp_end)
    SWAP_wd #(-1 strp_end len)

    # loop:
    DUP_wd _0BRANCH_wd 0A  #if len = 0, exit (jump dec10)

    # ( -1 [chars] strp len)
    SWAP_wd DUP_wd _at_wd _ROT_wd #( -1 [chars+1] len strp )

    _1minus_wd SWAP_wd _1minus_wd #( -1 [chars+1] strp-1 len-1 )

    BRANCH_wd 0FFF5 #loop (-dec11)
    # endloop

    _2DROP_wd # drop pointers
    EXIT_wd


TELL_hd: STRCHARS_hd 0 4 "TELL"
TELL_wd: do_colon # (strp - [prints string])
    STRCHARS_wd

    #loop
    DUP_wd _0ge_wd _0BRANCH_wd 4    #if ! >=0, , end of string, exit
    EMIT_wd BRANCH_wd 0FFFA #else emit, loop -6
    #endloop
    DROP_wd #drop the -1
    EXIT_wd


STR_eq_hd: TELL_hd 0 4 "STR="
STR_eq_wd: ? # (strp strp - ?equal)

    P1 P1; P2 P2;

    # Copy TOS into P1(-)
    P1 P1; TOS P1;

    # Pop NOS into P2(-1)
    ?+5 ?+4; NOSP_  ?+1; 0 P2; # GADGET: @NEGNOS(Z)
    i1 NOSP_; #shrink stack

    R R; ?+5 R; Z Z strcmp   ? #JSR

    # Result in X, copy to TOS
    TOS TOS; X Z; Z TOS;

    Z Z NEXT_cd



MEMCPY_hd: STR_eq_hd 0 6 "MEMCPY"
MEMCPY_wd: ? # (len src dst --)
# Copies len bytes from src to dst, moving upwards
    # copy TOS(destp) into P2(-)
    P2 P2; TOS P2;

    ### Pop NOS(srcp) into P1
    P1 P1;
    ?+5 ?+4; NOSP_  ?+1; 0 P1; # GADGET: @NEGNOS(P1)
    i1 NOSP_; #shrink stack

    ### Pop 3OS(len) into X(-)
    X X;
    ?+5 ?+4; NOSP_  ?+1; 0 X; # GADGET: @NEGNOS(X)
    i1 NOSP_; #shrink stack

    ### Pop 4OS() into TOS
    ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: @NEGNOS(X)
    i1 NOSP_; #shrink stack
    TOS TOS; Z TOS; Z Z;

    #jsr memcpy(len, src, dest) (return to NEXT_cd)
    R R; ?+5 R; Z Z memcpy   NEXT_cd #JSR

STRCPY_hd: MEMCPY_hd 0 6 "STRCPY"
STRCPY_wd: do_colon # (src_strp destp -- ) copies string from src to dest
    OVER_wd _at_wd # (src_strp destp len)
    _1plus_wd # We want to copy len+1 words
    _ROT_wd #bury the len field (len srcp destp)
    MEMCPY_wd EXIT_wd


DIGIT_cd_inval: #invalid character, return FF
    TOS TOS; nF0 TOS; nF TOS;
    Z Z NEXT_cd;

DIGIT_cd_az:
    # X holds char-'z' or char-'Z'
    # 'Z' should be dec35, 'A' should be dec10
    # Add dec35 (0x23),
    n20 X; n3 X;
    # Fall through to numdigit return
    Z Z ?+3

DIGIT_cd_09:
    # X holds char-'9'
    # Add 9, so '9' should be 9, '0' should be 0
    n9 X;
    TOS TOS; X Z; Z TOS;
    Z Z NEXT_cd;


DIGIT_hd: STRCPY_hd 0 5 "DIGIT"
    # Parses an ascii character into a digit
    # if char not in range [0-9a-zA-Z], outputs returns FF
DIGIT_wd: ? # (ascii_char - digit_value )

    X X; TOS Z; Z X; Z Z; # X(+) holds char

    # switch (X) {
    i20  X ;              #
    iF   X DIGIT_cd_inval #  X<=2F
    iA   X DIGIT_cd_09    #  X<=39, '0'-'9'
    i7   X DIGIT_cd_inval #  X<=40
    i10  X ;              #    (50)
    iA   X DIGIT_cd_az    #  X<=5A  'A'-'Z'
    i6   X DIGIT_cd_inval #  X<=60
    i10  X ;              #    (70)
    iA   X DIGIT_cd_az    #  X<=7A  'a'-'z'
    Z    Z DIGIT_cd_inval #  X>7A

    0d 0d 0d #should jump upward


# helper:
DROP_TO_neg1_wd: do_colon #( -1 [+num +num +num ] -- )
    # Loop as long as TOS >= 0
    _0lt_wd  _0BRANCH_wd 0FFFE #jump -2
    EXIT_wd

# Tries to parse strp as a number in the current BASE
# If gets an out of range digit, fails
# Handles leading -
NUMBER_hd: DIGIT_hd 0 6 "NUMBER"
NUMBER_wd: do_colon #(strp -- number 1  OR  0 )
    STRCHARS_wd # (-1 [lastchar ... firstchar] )

    # ==== PREPARE SIGN BIT on RS (0pos, 1neg)
    LIT_wd 0 #start pos

    # (-1 [chars] sign )
    OVER_wd LIT_wd 2D _eq_wd # if starts with '-'
    _0BRANCH_wd 004 #skip 3 (+4)
        # IF '-': Drop hyphen, change sign bit to 1
        SWAP_wd DROP_wd _1plus_wd
        # ELSE
    #THEN: Push sign bit to RS
    _toR_wd

    LIT_wd 0 #Start with total = 0

    #BEGIN ( -1 [chars...] total )
        OVER_wd _0ge_wd _0BRANCH_wd 16 # 0>= is 0 iff -1, jump exit (+dec22 wds, 0x16)
        # WHILE

        SWAP_wd DIGIT_wd # Parse digit ( -1 [...chars-1] total digit )

        # If DIGIT >= BASE, error
        DUP_wd BASE_wd _at_wd _ge_wd
        _0BRANCH_wd 07 #skip over 6 wods (+7)
            # IF digit >= base (-1 [chars] total digit )
            _2DROP_wd
            _fromR_wd # pop sign from RS (0 or 1)
            DROP_TO_neg1_wd # Drop all remaining chars
            #return  0
            LIT_wd 0000 EXIT_wd
        #THEN

        # multiply digit into total
        SWAP_wd BASE_wd _at_wd _times_wd _plus_wd
        # (-1 [chars] total)

        BRANCH_wd 0FFE8 # jump back dec24 words (-0x18)
    # END, jump back up

    # (-1 total)
    # Apply sign bit (from RS)
    _fromR_wd _0BRANCH_wd 2
        # If sign
        NEG_wd
    #THEN

    # return (total 1)
    SWAP_wd _2plus_wd EXIT_wd

# ================================================================
#
#                       DICTIONARY WORDS
#
# ================================================================
# , STR,
# (vars:) WIP
# CREATE
# >CFA >DFA
# : ;
# ?IMMED
# TODO: IMMEDIATE?
# FIND

_comma_hd: NUMBER_hd 0 1 ","
_comma_wd: do_colon #( x - [encloses x in dict] )
    DP_wd _at_wd _bang_wd #put X at *DP
    LIT_wd 1 DP_wd _plusbang_wd #inc DP
    EXIT_wd

STR_comma_hd: _comma_hd 0 4 "STR,"
STR_comma_wd: do_colon #( strp - [copies x into dict, encloses] )
    DP_wd _at_wd TUCK_wd  # ( DP@ strp DP@ )
    STRCPY_wd #Copy into dict (DP@)
    _at_wd # (strlen)
    _1plus_wd DP_wd _plusbang_wd # inc DP by strlen+1
    EXIT_wd

WIP_hd: STR_comma_hd 0 3 "WIP"
WIP_wd: do_var 0

CREATE_hd: WIP_hd 0 6 "CREATE"
CREATE_wd: do_colon # ( strp - )
    # creates wordheader at DP, encloses it in dict
    # links to LATEST

    # Create header:
    LATEST_wd _at_wd _comma_wd # link: latest
    LIT_wd 0 _comma_wd         # flags: 0
    STR_comma_wd               # enclose string header
    EXIT_wd

_toCFA_hd: CREATE_hd 0 4 ">CFA"
_toCFA_wd: do_colon #(word_header_address - CFA)
    _2plus_wd #skip link and flag
    DUP_wd _at_wd # get length
    _plus_wd _1plus_wd # Skip string
    EXIT_wd

_toDFA_hd: _toCFA_hd 0 4 ">DFA"
_toDFA_wd: do_colon #(word_header_address - DFA)
    _toCFA_wd _1plus_wd EXIT_wd

# TODO: this isn't correct, later gotta add proper flags
_qIMMED_hd: _toDFA_hd 0 6 "?IMMED"
_qIMMED_wd: do_colon #(word_header_address - 1/0 [if is immed])
    _1plus_wd _at_wd _0ne_wd EXIT_wd


_colon_hd: _qIMMED_hd 0 1 ":"
_colon_wd: do_colon
    # sets WIP to point to curr header
    DP_wd _at_wd WIP_wd _bang_wd  #point WIP to DP
    TOKEN_wd CREATE_wd    #read token + create header
    DO_COLON_wd _comma_wd #setup CFA with do_colon
    LIT_wd 1 STATE_wd _bang_wd #Enter compile mode
    EXIT_wd

_semicolon_hd: _colon_hd 1 1 ";" #IMMEDIATE
_semicolon_wd: do_colon
    LW_EXIT_wd _comma_wd #enclose EXIT_wd
    WIP_wd _at_wd LATEST_wd _bang_wd # Link WIP into latest
    LIT_wd 0 WIP_wd _bang_wd # Clear WIP
    LIT_wd 0 STATE_wd _bang_wd # exit compile mode

    # (DEBUG: Print out words as they're compiled)
    #LATEST_wd _at_wd _2plus_wd TELL_wd NL_wd

    EXIT_wd


# ( OLD IMPLEMENTATION: SUPESEDED BY ASM FIND_wd )
FIND_SECONDARY_wd: do_colon # (strp - [dict_header or 0])
    # Start searching at latest header
    LATEST_wd _at_wd SWAP_wd # ( hdrp strp )

    # loop (hdrp strp):
        OVER_wd _0BRANCH_wd  0E # if curr hdr is nullptr, jump to exit (+dec14)

        # ==== COMPARE TGT TO CURRENT HEADER get len, compare
        # (hdr str)
        #prepare 2 string pointers
        OVER_wd  # ( hdr str hdr )
        _2plus_wd OVER_wd #(hdr str hd_str str)

        # compare strings
        STR_eq_wd _0BRANCH_wd   3 # If strings equal
            DROP_wd EXIT_wd #( hdr str), return header
        # Else, (hdr str), go to next entry
        SWAP_wd _at_wd SWAP_wd # ( nexthdr str)

        BRANCH_wd 0FFF1 #jmp loop (-dec15, -F)
    #end loop

    # (0 strp) reached nullptr, return 0
    DROP_wd EXIT_wd

# =====
FIND_cd_nomatch: # ( we chased pointers until we hit 0, error out )
    TOS TOS;
    Z Z NEXT_cd


#FIND_ASM_hd: _semicolon_hd 0 4 "FIND"
FIND_hd: _semicolon_hd 0 4 "FIND"
FIND_wd: ? # ( strp - [ dict header or 0 ] )

    # === FUN COMPARISON: Call into FIND_SECONDARY instead for a speed comparison
    # CWA CWA ?+1 #leave room for a constant
    # FIND_SECONDARY_wd # constant, not executed
    # ?+FFFE Z; Z CWA ; # set CWA(+) to val of constant
    # Z Z RUN_cd # EXECUTE IT



    P1 P1; TOS P1; # target strp in P1(-)
    P2 P2; LATEST_val P2; # curr word strp in P2(-), start at LATEST

    # First time, don't need to advance P2
    Z Z ?+18 # skip over 8 triples, 0x18
FIND_cd_loop:
    # go to previous word header
    # P2 points to link field

    # P2(-) = WHA
    ?+5 ?+4; P2 ?+1; 0 Z; # GADGET:FETCH Z -= *(-P2)
    # Z(-) = LinkedWHA
    T T; Z T; P2 P2; T P2; Z Z; # copy Z(-) to P2(-)

    # P2(-) is now next WHA
    # if P2 is 0, we failed to find a match and need to return
    Z P2 ?+3 # if P2 <= 0, nextif
    Z Z  ?+3 # else P2 >0, skip
    P2 Z FIND_cd_nomatch # nextif P2>=0 (==0) we failed to find a match, exit

    # P2 is a valid word header, let's compare strings

    # we want to compare the string field, which is at WHA+2
    # Since we're negative, we want P2(-) -2
    i2 P2;  # P2 -= 2
    R R; ?+5 R; Z Z strcmp   ? #JSR strcmp(strp in P1-, strp in P2-)
    n2 P2;  # put P2 back to WHA

    # result in X, 1 means match
    Z X FIND_cd_loop # if X == 0, no match, keep searching
                      # else X=1, we found a match!

    # P2 points to WHA of matching word
    # return P2
    TOS TOS; P2 TOS; # TOS(+) = WHA in P2(-)
    Z Z NEXT_cd

# ================================================================
#
#                       EXECUTION WORDS
#
# ================================================================
HALTN_hd: FIND_hd 0 5 "HALTN"
HALTN_wd: ? # ( n -- [halts with code n] )
    Z Z ?+3 # skip over halt inst
haltn_cd1: 0
haltn_cd2: 0 haltn_cd1 # _ _ haltn
    # Copy TOS into place
    haltn_cd1 haltn_cd1; TOS Z; Z haltn_cd1; Z Z;
    haltn_cd2 haltn_cd2; TOS Z; Z haltn_cd2; Z Z;
    Z Z haltn_cd1 # jump to it


# Default exception handler
HANDLE_EXCEPT0_wd: do_colon
    #LIT_wd 6 HALTN_wd
    # print out "EXCEPTION: N"
    LITSTR_wd 0B "EXCEPTION: " TELL_wd
    DUP_wd LIT_wd "0" _plus_wd EMIT_wd NL_wd

    # Instead: clear exception, restart
    LIT_wd 0 IN_EXC_wd _bang_wd # clear exception
    LIT_wd restart_wd_addr _at_wd EXECUTE_wd # restart

    HALTN_wd
    # NOTE: if replaced, need to clear IN_EXC back to 0
    # to mark the exception as handled
    HALT1_wd # if failed, halt here

# INTERPRET

# Temp bootstrap words:
_qEXECUTE_wd: do_colon # ( wha -- )
    # IF state 0 or wd is immediate, execute
    # else compile it

    DUP_wd _toCFA_wd SWAP_wd # (cfa wha -- )


    #CSPLIT_wd EMIT_wd EMIT_wd
    _qIMMED_wd _0BRANCH_wd 3 #(cfa)
        # If immediate:
        EXECUTE_wd EXIT_wd

    # (cfa)
    STATE_wd _at_wd _0BRANCH_wd 3
        # If state=1 (compile)
        _comma_wd EXIT_wd

    #else: state = 0
    EXECUTE_wd EXIT_wd


_qNUMBER_wd: do_colon # ( N -- [?])
    # Compiles if state 1, else leaves on stack
    STATE_wd _at_wd _0BRANCH_wd 4
        # If state=1
        LW_LIT_wd _comma_wd _comma_wd #compile "LIT N"

    # If compiled, stack is empty
    # If state=0, leave number on stack
    EXIT_wd


_qSTACK_wd: ? # ( if DS or RS underflow, restart )
    X X ; NOSP_ X; # X holds NOSP(+)
    # If NOSP == dstack_base + 2, the stack is empty
    # If NOSP > dstack_base + 2, we've underflowed
    # IF (dstack_base+2-NOSP) < 0, we've underflowed
    # If (dstack_base+3-NOSP) <= 0, we've underflowed
    DS0_val Z; Z X; Z Z; # X = dstack_base(+)
    NOSP_ Z; Z X; # X = dstack_base - NOSP
    n3 X ; # X = dstack_base+3-NOSP

    Z X ?+3 # If <=0 (underflow, skip ahead)
    Z Z NEXT_cd # else all is well

    #==== UNDERFLOWED, print errors, go back to restart
    # Switch into seocndary mode for error handling
    Z Z; CWA CWA;
    ?+8 Z; Z CWA ; Z Z RUN_cd # SET CWA to point to rest of word, as a secondary, then exec
    ?        # CWA: address of rest of word as secondary
    do_colon # CW: do_colon

    LITSTR_wd 10 "STACK UNDERFLOW" 0A TELL_wd
    LIT_wd restart_wd_addr _at_wd EXECUTE_wd
    # shouldnt return
    LIT_wd 6 HALTN_wd


# If not compiling, output ok
_OK_wd: do_colon
_OK_wd_plus_1:
    STATE_wd _at_wd # 1: compiling
    _0BRANCH_wd 2 # if not compiling, skip
        # if compiling, exit:
        EXIT_wd
    LITSTR_wd 4 " OK" 0A # print " OK\n"
    TELL_wd
    EXIT_wd


SILENT_const: EXIT_wd # address of EXIT, we'll use it to overwrite OK
SILENT_hd: HALTN_hd 0 6 "SILENT"
SILENT_wd: ?
    # overwrites OK to exit immediately, used for bulkloading while
    # sourcing the bootstrap forth file
    _OK_wd_plus_1 _OK_wd_plus_1 ;      # clear first word of OK
    SILENT_const Z; Z _OK_wd_plus_1;  # set it to EXIT_wd
    Z Z NEXT_cd


INTERPRET1_wd: do_colon
    TOKEN_wd

    DUP_wd FIND_wd # Try FIND (tok wha|0 -- )
    DUP_wd
    _0BRANCH_wd 006
        # If found word,
        SWAP_wd DROP_wd #drop token
        _qEXECUTE_wd  # Exec/compile
        _qSTACK_wd EXIT_wd # check stack, exit

    DROP_wd # We have an extra 0 becasue we didn't ?DUP

    #ELSE:
    DUP_wd NUMBER_wd # Try NUMBER (tok (n 1 | 0) -- )
    _0BRANCH_wd 005
        # If found number
        SWAP_wd DROP_wd #drop token
        _qNUMBER_wd EXIT_wd

    #ELSE:
    # token is \n or invalid
    DUP_wd _1plus_wd _at_wd  # ( tok firstchar )
    LIT_wd 0A _eq_wd _0BRANCH_wd 004  # '\n' = IF
        # If was \n: continue
        DROP_wd
        _OK_wd
        EXIT_wd

    # ELSE: invalid token, print a warning, restart
    # ( tok )
    NL_wd TELL_wd
    LIT_wd 3F EMIT_wd  # '?'
    NL_wd

    # RESTART (the assmebler can't do forward labels, so init stashes the addr here)
    LIT_wd restart_wd_addr _at_wd EXECUTE_wd
    HALT1_wd #shouldn't reach here


INTERPRET_hd: SILENT_hd 0 9 "INTERPRET"
INTERPRET_wd: do_colon
    INTERPRET1_wd
    BRANCH_wd 0FFFE # branch -2


# ================================================================
#
#                      TEST FUNCS AND MAIN
#
# ================================================================


# Should emit "Hello"
TEST_STACK1_wd: do_colon
    LIT_wd 65 # e
    LIT_wd 6C # l
    LIT_wd 6F # o
    LIT_wd 48 # H
    LIT_wd 69 # i
    LIT_wd 78 # x
    LIT_wd 78 # x
    DROP_wd _2DROP_wd # ( e l o H )
    _ROT_wd # ( e H l o)
    _2SWAP_wd # ( l o e H )
    EMIT_wd
    EMIT_wd # "He" ( l o )
    SWAP_wd DUP_wd  # ( o l l )
    EMIT_wd EMIT_wd EMIT_wd # "llo"
    EXIT_wd



TEST_STACK2_wd: do_colon # should print "badc acb bac"
    ## Test 2SWAP, 2DROP
    LIT_wd 61 LIT_wd 62 LIT_wd 63 LIT_wd 64 # ( a b c d )
    _2SWAP_wd # ( c d a b )
    EMIT_wd EMIT_wd EMIT_wd EMIT_wd # "badc"
    SPACE_wd

    # Test ROT
    LIT_wd 61 LIT_wd 62 LIT_wd 63 # ( a b c )
    ROT_wd  # ( b c a)
    EMIT_wd EMIT_wd EMIT_wd #should print "acb"
    SPACE_wd

    # Test _ROT
    LIT_wd 61 LIT_wd 62 LIT_wd 63 # ( a b c )
    _ROT_wd  # ( c a b)
    EMIT_wd EMIT_wd EMIT_wd #should print "bac"

    EXIT_wd

TEST_RETSTACK_wd: do_colon
    # Test return stack
    NL_wd
    LIT_wd 49 # I
    LIT_wd 4A # J
    LIT_wd 4B # K
    LIT_wd 21 # !
    _toR_wd # ! should be hidden on return stack
    _ROT_wd SWAP_wd # ( K J I )
    EMIT_wd EMIT_wd EMIT_wd #should print "IJK"
    _fromR_wd EMIT_wd # "!"

    #_fromR_wd EMIT_wd # reads canary, 0xCAFE (emits 0xfe)
    EXIT_wd

TEST_VARS_wd: do_colon # should emit: 0A 10 0A 0A 20
    BASE_wd _at_wd EMIT_wd #Base starts at 0A
    LIT_wd 10 BASE_wd _bang_wd BASE_wd _at_wd EMIT_wd # Set to 0x10, fetch, emit

    LIT_wd 1 BASE_wd _plusbang_wd  #Add 1
    LIT_wd 7 BASE_wd _minusbang_wd #subtract 7
    BASE_wd _at_wd EMIT_wd #should emit 0A

    BASE_wd _at_wd EMIT_wd #should emit 0A

    DO_COLON_wd EMIT_wd #should emit 20 (since DO_COLON is at 0820?)

    EXIT_wd

TEST_MATH_wd: do_colon #Should emit 23 00 03 04 46 fa   20
                       #     then:  01 05 01 05 01 05 00 02 __  20 2A 00 80
    LIT_wd 5 LIT_wd 7 _times_wd EMIT_wd # 5*7=35 (0x23)
    LIT_wd 0 LIT_wd 3 _times_wd EMIT_wd # 0*3=0
    LIT_wd 3 LIT_wd 1 _times_wd EMIT_wd # 3*1=3
    LIT_wd 0FFFE LIT_wd 0FFFE _times_wd EMIT_wd #-2*-2, should be +4
    LIT_wd 0FFF6 LIT_wd 0FFF9 _times_wd EMIT_wd #-A*-7, should be +70 (0x46)
    LIT_wd 0FFFE LIT_wd 3 _times_wd EMIT_wd #-2*3, should be -6 (0xFFFA, emits fa)

    SPACE_wd

    LIT_wd 10 LIT_wd 3 U_divmod_wd EMIT_wd EMIT_wd #dec16 3 /MOD
    LIT_wd 0FFF0 LIT_wd 0FFFD U_divmod_wd EMIT_wd EMIT_wd #-dec16 -3 /MOD

    LIT_wd 0FFF0 LIT_wd 3 U_divmod_wd #-dec16 3 /MOD , should be (-5div -1rem)
    NEG_wd EMIT_wd NEG_wd EMIT_wd #should emit 01 05
    LIT_wd 0A LIT_wd 5 U_divmod_wd EMIT_wd EMIT_wd #0A 5 /MOD (exp: emit rem0 quot2)

    SPACE_wd
    LIT_wd 30 LIT_wd 2 _minus_wd LIT_wd 8 _minus_wd #dec 48 -2 -8 = dec38
    _1plus_wd _1plus_wd LIT_wd 2 _plus_wd # dec38 +1 +1 +2 = decimal42 = 0x2A '*'
    EMIT_wd


    SPACE_wd
    LIT_wd 0100 LIT_wd 2 U_divmod_wd EMIT_wd EMIT_wd  #should emit 0x00 0x80
    HALTN_wd

    EXIT_wd

TRUE_FALSE_wd: do_colon # (bool - 'T' or 'F')
    # If true, pushes T, else F
    LIT_wd 46 #'F'
    SWAP_wd _0BRANCH_wd 4 #if 0, stay on F
    DROP_wd LIT_wd 54 #'T' #else: T
    EXIT_wd
    0d 0d 0d

TEST_BRANCH_wd: do_colon # Prints "*****" using a loop
    #Comparisons should print a solid block of "T"

    LIT_wd 5
    # loop: (-8)
    _1minus_wd DUP_wd
    LIT_wd   2A   EMIT_wd
    _0BRANCH_wd 3 #if 0, jump ahead to exit
    BRANCH_wd 0FFF8

    NL_wd

    # Test comparisons
    LIT_wd 1 LIT_wd 1 #Should be TFFFTT
    _2DUP_wd _eq_wd         TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _ne_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _gt_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _lt_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _ge_wd         TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _le_wd         TRUE_FALSE_wd EMIT_wd
    _2DROP_wd NL_wd

    LIT_wd 2 LIT_wd 1 #Should be FTTFTF
    _2DUP_wd _eq_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _ne_wd         TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _gt_wd         TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _lt_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _ge_wd         TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _le_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    _2DROP_wd NL_wd

    LIT_wd 1 LIT_wd 2 #Should be FTFTFT
    _2DUP_wd _eq_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _ne_wd         TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _gt_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _lt_wd         TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _ge_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    _2DUP_wd _le_wd         TRUE_FALSE_wd EMIT_wd
    _2DROP_wd NL_wd

    LIT_wd 1 #Should be FTTFTF
    DUP_wd _0eq_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    DUP_wd _0ne_wd         TRUE_FALSE_wd EMIT_wd
    DUP_wd _0gt_wd         TRUE_FALSE_wd EMIT_wd
    DUP_wd _0lt_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    DUP_wd _0ge_wd         TRUE_FALSE_wd EMIT_wd
    DUP_wd _0le_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    DROP_wd NL_wd

    LIT_wd 0 #Should be TFFFTT
    DUP_wd _0eq_wd         TRUE_FALSE_wd EMIT_wd
    DUP_wd _0ne_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    DUP_wd _0gt_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    DUP_wd _0lt_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    DUP_wd _0ge_wd         TRUE_FALSE_wd EMIT_wd
    DUP_wd _0le_wd         TRUE_FALSE_wd EMIT_wd
    DROP_wd NL_wd

    LIT_wd 0FFFF #Should be FTFTFT
    DUP_wd _0eq_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    DUP_wd _0ne_wd         TRUE_FALSE_wd EMIT_wd
    DUP_wd _0gt_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    DUP_wd _0lt_wd         TRUE_FALSE_wd EMIT_wd
    DUP_wd _0ge_wd _0eq_wd TRUE_FALSE_wd EMIT_wd
    DUP_wd _0le_wd         TRUE_FALSE_wd EMIT_wd
    DROP_wd NL_wd

    EXIT_wd

TEST_TOKEN_wd: do_colon # Should consume several tokens
    # When reading in "1 2\n3\n 4\n"
    # Should output: "T1 T2 T\n T3 T4 T\n "
    # (i.e. shouldn't drop newlines)

    # Print T, then the token, then a space
    TOKEN_wd LIT_wd 54 EMIT_wd TELL_wd SPACE_wd
    TOKEN_wd LIT_wd 54 EMIT_wd TELL_wd SPACE_wd
    TOKEN_wd LIT_wd 54 EMIT_wd TELL_wd SPACE_wd
    TOKEN_wd LIT_wd 54 EMIT_wd TELL_wd SPACE_wd
    TOKEN_wd LIT_wd 54 EMIT_wd TELL_wd SPACE_wd
    TOKEN_wd LIT_wd 54 EMIT_wd TELL_wd SPACE_wd
    EXIT_wd

TEST_FIND_wd: do_colon #Takes input on STDIN: if valid word, should emit XT. Else emit 0
    # Emit ptr to LATEST
    LATEST_wd _at_wd CSPLIT_wd EMIT_wd EMIT_wd

    TOKEN_wd

    # TRY str= with token?
    #DUP_wd LATEST_wd _at_wd _2plus_wd STR_eq_wd EMIT_wd

    # Try to find token
    FIND_wd CSPLIT_wd EMIT_wd EMIT_wd

    # Try to find R>
    LITSTR_wd 0B "Finding R>" 0A TELL_wd
    LITSTR_wd 2 "R>" FIND_wd
    CSPLIT_wd EMIT_wd EMIT_wd

    EXIT_wd

TEST_NUMBER_wd: do_colon #Takes input on STDIN. Parses as number, emits
    TOKEN_wd

    #STRCHARS_wd DROP_TO_neg1_wd EMIT_wd EMIT_wd EMIT_wd EMIT_wd

    #LIT_wd 43 DIGIT_wd EMIT_wd #Parse 'C'

    NUMBER_wd
    EMIT_wd EMIT_wd

    EXIT_wd

TEST_STRCPY_wd: do_colon #Should emit "Hello"
    LITSTR_wd 5 "Hello"
    #DUP_wd EMIT_wd _at_wd EMIT_wd #debug: show ptr, show len

    DP_wd _at_wd
    STRCPY_wd #copy token to DP

    #DP_wd _at_wd _at_wd EMIT_wd

    #DP_wd _at_wd _at_wd EMIT_wd #DEBUG show len (DP@@)
    #DP_wd _at_wd _1plus_wd _at_wd EMIT_wd #DEBUG show len (DP@@)
    DP_wd _at_wd TELL_wd

    EXIT_wd

TEST_CREATE_wd: do_colon #Should emit 00 00 00 30 (first not found, then found)
    #Creates a new word at WIP called "HELLO"
    LITSTR_wd 5 "HELLO"
    CREATE_wd

    # Search for it
    LITSTR_wd 5 "HELLO"
    FIND_wd
    CSPLIT_wd EMIT_wd EMIT_wd

    # enclose HELLO at latest
    WIP_wd _at_wd LATEST_wd _bang_wd


    #LITSTR_wd 2 "R>"
    LITSTR_wd 5 "HELLO"
    FIND_wd
    CSPLIT_wd EMIT_wd EMIT_wd

    EXIT_wd

TEST_EXECUTE_wd: do_colon # Should emit "A"
    LIT_wd 41

    LITSTR_wd 4 "EMIT"
    FIND_wd _toCFA_wd
    #CSPLIT_wd EMIT_wd EMIT_wd #DEBUG: show found CFA
    EXECUTE_wd

    EXIT_wd

TEST_TAILCALL_wd: do_colon # should emit "A" and not "X"
    LIT_wd "A" TAILCALL_wd EMIT_wd
    LIT_wd "X" EMIT_wd # shouldn't be reached

TEST_EXCEPTION_wd: ?
    Z Z except3

# Should emit "H ii"
TEST_wd: do_colon
TEST_bd:
    #TEST_STACK1_wd SPACE_wd
    #TEST_STACK2_wd SPACE_wd
    #TEST_RETSTACK_wd SPACE_wd
    #TEST_VARS_wd
    TEST_MATH_wd

    #NOSP__wd EMIT_wd
    #RSP__wd EMIT_wd

    #TEST_BRANCH_wd

    #TEST_TOKEN_wd
    #TEST_FIND_wd

    #TEST_NUMBER_wd
    #TEST_STRCPY_wd
    #TEST_CREATE_wd

    #TEST_EXECUTE_wd
    #TEST_TAILCALL_wd
    #TEST_EXCEPTION_wd

    #INTERPRET_wd

    HALT1_wd


# Should never return
MAIN_wd: do_colon
    #TEST_wd
    INTERPRET_wd
    EXIT_wd

# ======= INITIAL CONSTS for startup stuff
forth_canary_val: 0CAFE
#forth_stack_base_val: dstack_base #(+)
forth_rstack_base_val: rstack_base
forth_init_dp_val: 3000
forth_init_e_handler: HANDLE_EXCEPT0_wd


# ========= STARTUP FLOW
# Restart: Resets transient state to known-good values for outer interp
#          ( BASE, WIP, STATE, etc )
#          Clears RSP (RESTART is outermost func)
#          Calls MAIN
#          if return from main, halt
_RESTART_CLEAR_STACKS_wd: ?
    # CLEAR DATA STACK
    NOSP_ NOSP_; DS0_val NOSP_; # NOSP(-) = DS0
    i2 NOSP_ ; #NOSP(-) -= 2 ; NOSP(-) = DS0+2
    # Init stack canary at TOS (will be written to DS0+1)
    TOS TOS; forth_canary_val Z; Z TOS; Z Z; #push CAFE to TOS as a marker?

    # Init return stack ( empty, rsp points 1 above RS0 )
    RSP_ RSP_; RS0_val RSP_; # RSP(-) = RS0
    i1 RSP_ ; # RSP(-) -=1, RSP = RS0+1

    # continue with restart
    Z Z NEXT_cd


# If main returns, it will return here, so we can error out
RESTART_hd: INTERPRET_hd 0 7 "RESTART"
RESTART_wd: do_colon
RESTART_bd:
    #NOTE: start doesn't enter through do_colon, it just sets NWA to
    # start executing here.

    # CLEAR_STACKS, so it won't touch either stack
    _RESTART_CLEAR_STACKS_wd

    # clear compile mode
    LIT_wd 0 STATE_wd _bang_wd

    # Clear any WIP words
    # If WIP word > LATEST, reset DP to WIP, clear IWP
    WIP_wd _at_wd LATEST_wd _at_wd _gt_wd _0BRANCH_wd 0009
        # If WIP>LATEST
        WIP_wd _at_wd DP_wd _bang_wd # set DP back to discard WIP word
        LIT_wd   0000 WIP_wd _bang_wd # clear WIP

    # Stacks are initialized and clear

    #=== Reset normal variables
    LIT_wd 0A BASE_wd _bang_wd # BASE 10

    #=== Greet, start
    LITSTR_wd 08 "STARTING" TELL_wd NL_wd
    MAIN_wd # JUMP TO MAIN

    # SHOULDN'T EXIT
    LITSTR_wd 0B "MAIN EXITED" TELL_wd NL_wd
    HALT1_wd


# ======= INITIAL CONSTS for startup stuff
forth_init_restart_wd: RESTART_wd # first forth word we jump to after START


# Start: inits persistent state constants
#   Sets up for execution of primaries (SP, TOS, canaries)
#
#   Copies in initial constants that we weren't able to due to assembler
#        Setups up NWA to point to RESTART, jumps to NEXT
#        ( LATEST, DP, etc, NOSP_, etc )
#
forth_init_latest_val: ? # Constant that points to START_hd
START_hd: RESTART_hd 0 5 "START"
START_wd: ?
START_cd: # Starts executing here with no state
    #=== INIT STACK
    # (Stack base is at DS0. First item on stack will be at DS0
    #  With empty stack, SP should point to DS0+1
    #  Because we're using NOSP (TOS in a reg), NOSP points to DS0+1)
    #NOSP_ NOSP_; forth_stack_base_val NOSP_; # NOSP(-) = DS0
    NOSP_ NOSP_; DS0_val NOSP_; # NOSP(-) = DS0
    i2 NOSP_ ; #NOSP(-) -= 2 ; NOSP(-) = DS0+2

    # Init stack canary at TOS (will be written to DS0+1)
    TOS TOS; forth_canary_val Z; Z TOS; Z Z; #push CAFE to TOS as a marker?


    # ==== START EXECUTING RESTART
    # ( it will initialize return stack and other vars)

    # set up NWA to point to first word of RESTART
    #   ( we don't want to enter RESTART as a subword, just start executing )
    NWA NWA; forth_init_restart_wd Z; Z NWA; # NWA = RESTART >CFA
    n1 NWA; # NWA = RESTART >DFA
    Z Z NEXT_cd # Start executing restart


# =============================== MAIN LOOP

#Note: expects first char of input in C (-)
# clobbers X, jumps to one of the parser funcs
# parser funcs jump back here (directly, not using return mechanism)

@2000 # main
Z Z 2100
Z Z halt0



@2100 # forth_init
    # SUBLEQ ASM STUFF

    # write 0d to entry so that we halt if we start executing at 0
    entry entry; nD entry;

    # ==== Init consts
    # (we'd assemble these directly but we don't
    #  have forward labels in asm2)
    DP_val          DP_val         ; forth_init_dp_val     Z; Z DP_val;     Z Z;
    LATEST_val      LATEST_val     ; forth_init_latest_val Z; Z LATEST_val; Z Z;
    restart_wd_addr restart_wd_addr; forth_init_restart_wd Z; Z restart_wd_addr; Z Z;
    e_handler_val   e_handler_val  ; forth_init_e_handler  Z; Z e_handler_val; Z Z;


    Z Z START_cd # Jump to START



@2200 # custom_test:
# alternate entry for calling into test funcs?
    Z Z halt0  # exit


#...
#@3000 is dict, grows upward


# ========== GADGETS / CODE SNIPPETS


#Snippets:
#
# JLEZ(X,LOC): Z X LOC
# JGEZ(X,LOC): T T; X T LOC
# JGTZ(X,LOC): T T; $-1 T; X T LOC;
# JLTZ(X,LOC): T T; X T ?+3; Z Z LOC;
#
# SUBJGE(X,Y,LOC): X Y LOC;            #Y -= X
# SUBJLE(X,Y,LOC): T T; X Y; Y T LOC;  #Y -= X
#
# Safe Comparisons: (avoids 0x8000 looking like 0)
#
# ### Full compare: check LTZ, GTZ, EQZ, restore variable
#    Z  T ?+3 #if T <= 0; goto nextif
#    Z  Z ?+9 # KNOW:>0, jmp GTZ
#    n1 T ?+3 # nextif T+1<=0 (then: KNOW:T<0):
#             # KNOW: T==0
#    i1 T XXX # EQZ: i1 T XXX ( undo +, always jumps)
#    i1 T XXX # LTZ: i1 T (undo +, always jumps)
#    Z  Z XXX # GTZ: Z Z (+)
#
# ### Quick compare (EQ/NEZ, clobber variable)
#    Z  T ?+3 # if T <= 0; nextif
#    Z  Z ?+6 # KNOW:>0, jmp GTZ
#    n1 T ?+3 # nextif T+1<=0 (KNOW:T<0, jmp LTZ):
#    Z Z EQZ  # KNOW: T==0
#    # ELSE: T<>0
#    ...
# ### Quick compare, jump to label (EQ/NEZ, clobber variable)
#    Z  T ?+3 # if T <= 0; nextif
#    Z  Z GTZ # KNOW:>0, jmp GTZ
#    n1 T LTZ # nextif T+1<=0 (KNOW:T<0, jmp LTZ):
#    Z Z EQZ  # KNOW: T==0
#
# JGE(X,Y,LOC): T T; Y Z; Z T; Z Z; X T LOC;
# JLE: mirror
#
# GADGET: jsr  (1-level)
#   R  R  ?
# ?+5  R  ?            # copy constant retaddr to R(-)
#   Z  Z  sub_routine  # jump subroutine
#   ?                  # constant ret_addr
#   _  _  _            # returns to here
#
# (JSR oneliner)
# R R; ?+5 R; Z Z subroutine   ? #JSR
#
# GADGET: retsub  (1-level)
# ?+7 ?+6    ?
#   R ?+3    ?    #set Q = -R
#   Z   Z  Q:0    #jmp -R
#


# GADGET: FETCH_SUBTRACT: *(-P) X
# ?+5 ?+4; #   : Q   Q     #
#   P ?+1; #   : P   Q     #
#   _   X; #   : Q:_ X     # X -= *(-P)

# GFETCH_SUB:   ptr(-)       tgt
# ?+5 ?+4;        P   ?+1; 0  X;  # X -= *(-P)
#
# GFETCH:           ptr(-)         tgt
# X X; ?+5 ?+4;        P   ?+1; 0  X;  # X = -*(-P)
#
# X X; ?+5 ?+4; P1 ?+1; 0 X; # GADGET:FETCH X = -*(-P1)
# ?+5 ?+4; P1 ?+1; 0 X; # GADGET:FETCH X -= *(-P1)
#
# ?+6  ?+5 ; P1 ?+2 ; X 0; # GADGET: POKESUB(P1), *(-P1) -= X
#
# # GADGET: POKE: *(P-) = -X
# ?+11 ?+10; P_ ?+D;  # set J
# ?+C  ?+B ; P_ ?+8;  # set K
# ?+9  ?+8 ; P_ ?+5;  # set L
# 0    0   ; X_   0;  # J K; (_) L

# # GADGET: POKE:
# ?+11 ?+10; P_ ?+D; # *(P-) = -X
# ?+C  ?+B ; P_ ?+8; # .
# ?+9  ?+8 ; P_ ?+5; # .
# 0    0   ; X_   0; # .
#
## ===== Stack Gadgets
# ### Push TOS into NOS
# T T; TOS T;
# n1 NOSP_; #grow stack
# ?+11 ?+10; NOSP_ ?+D; # GADGET: NEG!NOS(T)
# ?+C  ?+B ; NOSP_ ?+8; # .
# ?+9  ?+8 ; NOSP_ ?+5; # .
# 0    0   ; T   0; # .
#
# ### Pop NOS into Z
# ?+5 ?+4; NOSP_  ?+1; 0 Z; # GADGET: @NEGNOS(Z)
# i1 NOSP_; #shrink stack
#
#
# ### Switch from secondary to primary
# ? # Forth-word: next cell
# ? # CF: execute next cell as asm
# # ... asm
#
# ### Switch from primary to secondary
# Z Z; CWA CWA;
# ?+8 Z; Z CWA ; Z Z RUN_cd # SET CWA to point to rest of word, as a secondary, then exec
# ? # address of rest of word as secondary
# do_colon # start of word
