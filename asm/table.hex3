# Test file to figure out how to use tables, stacks, etc
#




#NOTE: all pointers are neg
#TODO: Snippet for reading from contents of pointer
#TODO: Snippet for inserting into table
#TODO: Snippet for walking table from pointer, check each entry to see if it matches


# =========  HEADER

@0  # Z T entry       P1  M1  0 0
     0 0 100   0      1 FFFF 0 0
@8  # I O A B     _ _ _ _
      0 0 0 0     0 0 0 0
@10 # & | ^ _   << >> _ _  (ALU)
      0 0 0 0   0  0  0 0

# ========  REGISTERS AND CO.

@20 # X Y P Q           R  (REGS)
      0 0 0 0     0 0 0 0

# leave rooms for vars at 28-2F
@28 #                    TS  TB          (VARS)
      00  00  00  00     00 800  00  00

#TS is table_size (num_entries)
#TB is address of table (+)

# ======== CONSTANTS
# Mnemonics: 
#    +/- single digits: 4 is +1, 5 is -1, lets make 4X be +X, 5X be -X
#    +/- nibs place: like 4 but shifted up to 8

@40 #4_: 0-F
0 1 2 3 4 5 6 7 8 9 A B C D E F

@50 #5_: negative 0-F
0000 FFFF FFFE FFFD FFFC FFFB FFFA FFF9 
FFF8 FFF7 FFF6 FFF5 FFF4 FFF3 FFF2 FFF1

@80 #8_: 0-F
0 10 20 30 40 50 60 70 80 90 A0 B0 C0 D0 E0 F0

@90 #9_: (-00) - (-F0)
0000 FFF0 FFE0 FFD0 FFC0 FFB0 FFA0 FF90
FF80 FF70 FF60 FF50 FF40 FF30 FF20 FF10

@D0 #error_page
   0  0 D0    #D0:   halt0 #success
   1  1 D3    #D3:   halt1 
   2  2 D6    #D6:   halt2 
   3  3 D9    #D9:   halt3 
   4  4 DC    #DC:   halt4
   5  5 DC    #DF:   halt5

@F0 #retsub:
?+7 ?+6   ?   # Q Q
 27 ?+3   ?   # R Q      # set Q = -R
  0   0   0   # 0 0 Q:_  # jmp -R

# ======== CODE

@100 #entry:
   0   0 200  #   : main


@200 #main
# First does table_insert(3,59) 'Y'
# First does table_insert(1,48) 'H'
# First does table_insert(2,45) 'E'
# They should end up at addresses (TB, TB+02)
   0   0   ?  #   : 
  20  20   ?  #   : X X
   0  20   ?  #   : $-00 X
  53  20   ?  #   : $-3 X
  21  21   ?  #   : Y Y
  95  21   ?  #   : $-50 Y
  59  21   ?  #   : $-9 Y
 27 27 ?  ?+5 27 ?  0 0   300 ?  #JSR table_insert
 #insert_neg(3,x59)
 

  20  20   ?  #   : X X
   0  20   ?  #   : $-00 X
  51  20   ?  #   : $-1 X
  21  21   ?  #   : Y Y
  94  21   ?  #   : $-40 Y
  58  21   ?  #   : $-8 Y
 27 27 ?  ?+5 27 ?  0 0   300 ?  #JSR table_insert
 #insert_neg(1,x48)
 #
  20  20   ?  #   : X X
   0  20   ?  #   : $-00 X
  52  20   ?  #   : $-2 X
  21  21   ?  #   : Y Y
  94  21   ?  #   : $-40 Y
  55  21   ?  #   : $-5 Y
 27 27 ?  ?+5 27 ?  0 0   300 ?  #JSR table_insert
 #insert_neg(2,x45)


#now fetch 3 vals in order
  20  20   ?  #   : X X       # 
  51  20   ?  #   : $-1 X     # 
 27 27 ?  ?+5 27 ?  0 0   500 ?  #JSR table_search
 #search(1)
  20   0   ?  #   : X Z       # 
   0   9   ?  #   : Z O       # output char (neg)


  20  20   ?  #   : X X       # 
  52  20   ?  #   : $-2 X     # 
 27 27 ?  ?+5 27 ?  0 0   500 ?  #JSR table_search
 #search(2)
  20   0   ?  #   : X Z       # 
   0   9   ?  #   : Z O       # output char (neg)


  20  20   ?  #   : X X       # 
  53  20   ?  #   : $-3 X     # 
 27 27 ?  ?+5 27 ?  0 0   500 ?  #JSR table_search
 #search(3)
  20   0   ?  #   : X Z       # 
   0   9   ?  #   : Z O       # output char (neg)



# make sure that not-found values signal correctly
  20  20   ?  #   : X X       # 
  54  20   ?  #   : $-4 X     # 
 27 27 ?  ?+5 27 ?  0 0   500 ?  #JSR table_search
 #search(4) this should fail, returning Y=0 (not found)
   0  21  D0  #   : Z Y halt0 #  IF Y == 0, we're good, halt0
   0   0  D9  #   : halt3     #  Else: rip it should have been 0, halt3
   

   0   0   ?  #   :           # 



#=============================================
@300 #table-insert:

# Puts X and Y at next position in table (neg)
# increments TS by 2, then returns
   0   0   ?  #   :           #
  22  22   ?  #   : P P
  2D  22   ?  #   : TB P
  2C  22   ?  #   : TS P
  2C  22   ?  #   : TS P      # P = -(TB + 2*TS)
                              # now want to put X at *(P-)
                              
# P(-) now points to next free slot in the table
# We need to clear and then subtract, two ops, 3 pointers
# setting each ptr takes 2 ops, so 6 ops to set them
# + the 2 ops themselves
# Would be way easier if I didn't need to clear (only 4 ops)
 ?+11 ?+10 ? # J J            #  *(P-) = -X
   22 ?+D  ? # P J            #  . 
  ?+C ?+B  ? # K K            #  . 
   22 ?+8  ? # P K            #  . 
  ?+9 ?+8  ? # L L            #  . 
   22 ?+5  ? # P L            #  . 
    0   0  ? # J:_ K:_        #  . 
   20   0  ? #  X  L:_        #  . 


#Now Y goes in the next table slot
    4  22  ? # $1 P 
 ?+11 ?+10 ? # J J            #  *(P-) = -Y
   22 ?+D  ? # P J            #  . 
  ?+C ?+B  ? # K K            #  . 
   22 ?+8  ? # P K            #  . 
  ?+9 ?+8  ? # L L            #  . 
   22 ?+5  ? # P L            #  . 
    0   0  ? # J:_ K:_        #  . 
   21   0  ? #  Y  L:_        #  . 

#Done, inc number of entries
   5  2C   ?  #   : $-1 TS    # Inc TS
   0   0  F0  #   : jmp retsub

   0   0   ?  #   :           # 
   0   0   ?  #   :           # 
   0   0   ?  #   :           # 




#=============================================
@500 #table-search:

# Searches for key "X" in table 
# Returns associated value in X
# Y holds 0 if err, 1 iff success
# uses xypq
#
#
  23  23   ?  #   : Q Q       # 
  2C  23   ?  #   : TS Q      # Q = -TableSize
  22  22   ?  #   : P P       # 
  2D  22   ?  #   : TB P      # P = - TBase
   0   0 540  #   : z z looptest (jump into test)

# we only want to loop as many times as table_size,
# then fall through to "not found"
#each time P-=2
#If *(P-) == X, found
# Loop invariants: when entering at top: will do body (-Q) + 1 times
# Loop invariants: when entering at looptest: will do body (-Q) times
# P(-) points to current critter to test
# X is target value
# Q is counter == neg length of table

@520
# table_search_loop  :
   0   0   ?  #   :           # 
  21  21   ?  #   : Y Y       # Fetch value
 ?+5 ?+4   ?  #   : Q Q       # 
  22 ?+1   ?  #   : P Q       # 
   0  21   ?  #   : Q:_ Y     # Y = -*(-P)


                              # Compare X to key in table
                              # NOTE: table contents are (-)
  20  21 ?+3  #   : X Y ?+3   # Y -= 0: if >0,false
   0   0 ?+3  #   : Z Z next  # 
  21   0 580  #   : Y Z tsrch_found   # if -Y <= 0, true    (Y <=0 && -Y <=0)

                              # if !=, continue
  42  22   ?  #   : $2 P      # P -= 2
   0   0 540  #   :  Z Z looptest       


@540 #looptest:
   5  23 520  #   : $-1 Q loop # Q++, JLEQZ loop

#tsearch_notfound:
                              # Finished table, didn't find val
  21  21   ?  #   : Y Y       # Y = 0 (not found)
  20  20  F0  #   : X X       # X = 0 (null), retsub

@580
#tsearch_found:
                              # P(-) is at matching key
   4  22   ?  #   : $1 P      # P--

  20  20   ?  #   : X X       # fetch P (val)
 ?+5 ?+4   ?  #   : Q Q       # 
  22 ?+1   ?  #   : P Q       # 
   0  20   ?  #   : Q:_ X     # X = -*(-P)

  21  21   ?  #   : Y Y       # 
   5  21   ?  #   : $-1 Y     # Y = 1 (success)
   0   0  F0  #   : jmp retsub# return


   0   0   ?  #   :           # 
   0   0   ?  #   :           # 






## TODO: Do something clever to set x and y looping-style
## TODO: Write a MEMCLR(at=X,len=Y) operation
## TODO: Write intern-string method?

@800 #table
# Each entry is 2 words long: first word is key, second is value

# ========= NOTES

#Snippets:
#
# JLEZ(X,LOC): Z X LOC 
# JGEZ(X,LOC): T T; X T LOC
# JGTZ(X,LOC): T T; $-1 T; X T LOC;
# JLTZ(X,LOC): T T; X T ?+3; Z Z LOC;
#
# SUBJGE(X,Y,LOC): X Y LOC;            #Y -= X
# SUBJLE(X,Y,LOC): T T; X Y; Y T LOC;  #Y -= X
#
#
# JGE(X,Y,LOC): T T; Y Z; Z T; Z Z; X T LOC;
# JLE: mirror
#
# CLR (P)    5 ops
# *(Pm) = 0:
#     JJ KK 
#     PJ PK
#     J:_ K:_
#
# SUB X, (P)   3 ops
# *(Pm) -= *X:
#     LL PL
#     P  L:_
#
# MOV X, (P)    8 ops
# *(Pm) = *X:
#     JJ KK LL
#     PJ PK PL
#     J:_ K:_
#       X L:_
#
# NOTE: 
#  MEMCLR(base, size) can be implemented with only 4 ops/word
#  MEMSET(base, size, val) can be implemented with 6 ops/word
#  MEMCPYNEG(to, from, len) can be implemented with 7 ops/word
#  MEMCPYPOS(to, from, len) can be implemented with 9 ops/word
#
#
# GADGET: jsr  (1-level)
#   R  R  ?
# ?+5  R  ?            # copy constant retaddr to R(-)
#   Z  Z  sub_routine  # jump subroutine
#   ?                  # constant ret_addr
#   _  _  _            # returns to here
#
# GADGET: JSR one-liner
#   27 27 ?  ?+5 27 ?  0 0 sub_routine  ?  #JSR 
#
# GADGET: retsub  (1-level)
# ?+7 ?+6    ?
#   R ?+3    ?    #set Q = -R
#   Z   Z  Q:0    #jmp -R
#
#
#
# GADGET: FETCH_SUBTRACT: *(-P) X
#  ?+5 ?+4  ?  #  Q   Q 
#    P ?+1  ?  #  P   Q
#    _   X  ?  #  Q:_ X    # X -= *(-P)
#
#
# GADGET: POKE: *(P-) = -X
# ?+11 ?+10 ? # J J            #  *(P-) = -X
#   22 ?+D  ? # P J            #  . 
#  ?+C ?+B  ? # K K            #  . 
#   22 ?+8  ? # P K            #  . 
#  ?+9 ?+8  ? # L L            #  . 
#   22 ?+5  ? # P L            #  . 
#    0   0  ? # J:_ K:_        #  . 
#   20   0  ? #  X  L:_        #  . 
